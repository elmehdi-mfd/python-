# -*- coding: utf-8 -*-
import os
import sqlite3
from datetime import datetime
import customtkinter as ctk
from CTkMessagebox import CTkMessagebox
from tkinter import ttk, filedialog
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet
from datetime import datetime
import os
from datetime import datetime
import pytz
import bcrypt
import datetime
import logging
from datetime import datetime
import pandas as pd
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet
from PIL import Image, ImageTk
import os
from tkinter import filedialog
import json


import sqlite3
import customtkinter as ctk
import bcrypt
import logging
from datetime import datetime
import pytz

class LoginWindow:
    def __init__(self, root):
        self.root = root
        self.root.title("Centre de Soutien - Login")
        self.root.geometry("800x600")
        
        # Configuration de l'apparence
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("blue")
        
        # Variables
        self.email_var = ctk.StringVar()
        self.password_var = ctk.StringVar()
        
        # Cr√©er l'interface
        self.create_login_interface()
        
    def create_login_interface(self):
        # Frame principal avec padding augment√©
        main_frame = ctk.CTkFrame(self.root)
        main_frame.pack(fill="both", expand=True, padx=40, pady=40)
        
        # Logo ou titre
        ctk.CTkLabel(
            main_frame,
            text="Centre de Soutien",
            font=("Arial", 36, "bold")
        ).pack(pady=30)
        
        # Frame pour le formulaire
        form_frame = ctk.CTkFrame(main_frame)
        form_frame.pack(fill="x", padx=40, pady=30)
        
        # Champ email
        ctk.CTkLabel(
            form_frame,
            text="Email",
            font=("Arial", 14)
        ).pack(anchor="w", pady=(20, 0))
        
        email_entry = ctk.CTkEntry(
            form_frame,
            textvariable=self.email_var,
            width=400,
            height=40,
            placeholder_text="Entrez votre email"
        )
        email_entry.pack(pady=(5, 15))
        
        # Champ mot de passe
        ctk.CTkLabel(
            form_frame,
            text="Mot de passe",
            font=("Arial", 14)
        ).pack(anchor="w", pady=(20, 0))
        
        password_entry = ctk.CTkEntry(
            form_frame,
            textvariable=self.password_var,
            width=400,
            height=40,
            show="‚Ä¢",
            placeholder_text="Entrez votre mot de passe"
        )
        password_entry.pack(pady=(5, 25))
        
        # Bouton de connexion
        login_button = ctk.CTkButton(
            form_frame,
            text="Se connecter",
            command=self.login,
            width=300,
            height=50,
            font=("Arial", 16, "bold")
        )
        login_button.pack(pady=30)
        
        # Message d'erreur
        self.error_label = ctk.CTkLabel(
            form_frame,
            text="",
            text_color="red",
            font=("Arial", 14)
        )
        self.error_label.pack(pady=15)

    def show_error(self, message):
        """Affiche un message d'erreur"""
        self.error_label.configure(text=message)
        self.error_label.pack()
        self.root.after(3000, lambda: self.error_label.configure(text=""))

    def verify_credentials(self, email, password):
        """V√©rifie les identifiants dans la base de donn√©es"""
        try:
            conn = sqlite3.connect('centre_soutien.db')
            cursor = conn.cursor()
            
            print(f"\nEmail saisi: {email}")
            print(f"Current Date and Time (UTC): {datetime.now(pytz.UTC).strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"Current User's Login: elmehdi-mfd")
            
            # V√©rifier si l'utilisateur existe
            cursor.execute("SELECT * FROM utilisateurs WHERE email = ?", (email,))
            user = cursor.fetchone()
            
            if user:
                # Le mot de passe est d√©j√† hash√© dans la base de donn√©es
                stored_password = user[4]
                if isinstance(stored_password, str):
                    stored_password = stored_password.encode('utf-8')
                
                if bcrypt.checkpw(password.encode('utf-8'), stored_password):
                    self.current_user = {
                        'id': user[0],
                        'nom': user[1],
                        'prenom': user[2],
                        'email': user[3],
                        'role': user[5],
                        'full_name': f"{user[1]} {user[2]}"
                    }
                    return True
            return False
            
        except sqlite3.Error as e:
            print(f"Erreur de base de donn√©es: {e}")
            return False
        finally:
            if conn:
                conn.close()

    def login(self):
        """G√®re la tentative de connexion"""
        email = self.email_var.get().strip()
        password = self.password_var.get().strip()
        
        if not email or not password:
            self.show_error("Veuillez remplir tous les champs")
            return
        
        if self.verify_credentials(email, password):
            print("Connexion r√©ussie!")
            self.successful_login(email)
        else:
            print("√âchec de la connexion")
            self.show_error("Email ou mot de passe incorrect")

    def successful_login(self, email):
        """G√®re la connexion r√©ussie"""
        try:
            root = ctk.CTk()
            app = SchoolFeeManagementApp(root, self.current_user)  # Utilisez directement la classe
            self.root.destroy()
            root.mainloop()
        except Exception as e:
            print(f"Erreur lors du d√©marrage de l'application: {e}")
            self.show_error("Erreur lors du d√©marrage de l'application")
			
class SchoolFeeManagementApp:
    def __init__(self, root, user_info):
        self.root = root
        self.user_info = user_info
        self.user_email = user_info['email']
        self.user_role = user_info['role']
        self.user_full_name = user_info['full_name']
        
        # Configuration de la fen√™tre principale
        self.root.title(f"Centre de Soutien - {self.user_full_name}")
        self.root.geometry("1300x850")
        # G√©rer la fermeture de la fen√™tre
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        # Configuration de l'apparence
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("blue")
        
        # Initialisation des variables
        self.sort_reverse = False
        self.current_school_name = None
        self.primary_amount = None
        self.payment_status_thread = None
        self.stop_payment_tracking = False
        
        # Connexion √† la base de donn√©es
        self.setup_database()
        
        # Cr√©ation de l'interface
        self.create_main_interface()
		
    def setup_database(self):
        """Initialise la connexion √† la base de donn√©es"""
        try:
            self.conn = sqlite3.connect('centre_soutien.db')
            self.cursor = self.conn.cursor()
            
            # V√©rifier si les tables n√©cessaires existent
            self.create_required_tables()
            
        except sqlite3.Error as e:
            print(f"Erreur lors de la configuration de la base de donn√©es: {e}")
            raise	
			
			
    def create_required_tables(self):
        """Cr√©e les tables n√©cessaires si elles n'existent pas"""
        try:
            # Table pour la configuration des frais
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS FeeConfiguration (
                    id INTEGER PRIMARY KEY,
                    level TEXT,
                    amount REAL
                )
            ''')

            # Table pour les mati√®res
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS Subjects (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    level TEXT NOT NULL,
                    name TEXT NOT NULL,
                    fee REAL NOT NULL,
                    UNIQUE(level, name)
                )
            ''')

            # Table pour les √©tudiants
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS Students (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    surname TEXT NOT NULL,
                    birth_date TEXT,
                    gender TEXT,
                    address TEXT,
                    class TEXT NOT NULL,
                    phone_number TEXT,
                    parent_name TEXT,
                    parent_phone TEXT,
                    email TEXT,
                    registration_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    photo_path TEXT,
                    subjects TEXT,
                    total_fee REAL DEFAULT 0,
                    total_paid REAL DEFAULT 0,
                    last_payment_date TEXT,
                    payment_completed INTEGER DEFAULT 0
                )
            ''')

            # Table pour les paiements
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS Payments (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    student_id INTEGER,
                    amount REAL NOT NULL,
                    payment_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    payment_method TEXT,
                    notes TEXT,
                    FOREIGN KEY(student_id) REFERENCES Students(id)
                )
            ''')

            self.conn.commit()
            print("Tables cr√©√©es avec succ√®s")

        except sqlite3.Error as e:
            print(f"Erreur lors de la cr√©ation des tables: {e}")
            raise
			
    def logout(self):
        """G√®re la d√©connexion de l'utilisateur"""
        try:
            # Nettoyer les tooltips
            for widget in self.root.winfo_children():
                if hasattr(widget, 'tooltip'):
                    self._hide_tooltip(widget)
    
            # Fermer proprement la fen√™tre actuelle
            if hasattr(self, 'school_config_tabview'):
                self.school_config_tabview.destroy()
            
            if hasattr(self, 'main_frame'):
                self.main_frame.destroy()
    
            # Fermer la connexion √† la base de donn√©es
            if hasattr(self, 'conn'):
                self.conn.close()
    
            # D√©truire la fen√™tre principale
            self.root.destroy()
    
            # Cr√©er une nouvelle fen√™tre de connexion
            new_root = ctk.CTk()
            LoginWindow(new_root)
            new_root.mainloop()
    
        except Exception as e:
            print(f"Erreur lors de la d√©connexion: {e}")
    
    def on_closing(self):
        """G√®re la fermeture de l'application"""
        try:
            # Nettoyer les tooltips
            for widget in self.root.winfo_children():
                if hasattr(widget, 'tooltip'):
                    self._hide_tooltip(widget)
    
            # Fermer proprement les composants
            if hasattr(self, 'school_config_tabview'):
                self.school_config_tabview.destroy()
    
            if hasattr(self, 'main_frame'):
                self.main_frame.destroy()
    
            # Fermer la connexion √† la base de donn√©es
            if hasattr(self, 'conn'):
                self.conn.close()
    
            # Fermer l'application
            self.root.quit()
            self.root.destroy()
    
        except Exception as e:
            print(f"Erreur lors de la fermeture: {e}")
            self.root.destroy()
		
		
    def create_main_interface(self):
        """Cr√©e l'interface principale de l'application"""
        # Frame principal
        self.main_frame = ctk.CTkFrame(self.root)
        self.main_frame.pack(fill="both", expand=True)
        
       # Frame principal avec une hauteur fixe tr√®s r√©duite
        header_frame = ctk.CTkFrame(self.root, height=35)
        header_frame.pack(fill="x", padx=2, pady=(2,0))
        header_frame.pack_propagate(False)  # Emp√™che le frame de s'agrandir
        
        # Frame pour le nom d'utilisateur (√† gauche)
        user_frame = ctk.CTkFrame(header_frame, fg_color="transparent")
        user_frame.pack(side="left", padx=5)
        
        # Ic√¥ne utilisateur et nom (plus petit)
        ctk.CTkLabel(
            user_frame,
            text="üë§",  # Ic√¥ne utilisateur
            font=("Arial", 12)  # Taille de police r√©duite
        ).pack(side="left")
        
        ctk.CTkLabel(
            user_frame,
            text=f"{self.user_full_name}",
            font=("Arial", 12)  # Taille de police r√©duite
        ).pack(side="left", padx=5)
        
        # Bouton de d√©connexion (plus petit)
        logout_button = ctk.CTkButton(
            header_frame,
            text="D√©connexion",
            command=self.logout,
            width=80,  # Largeur r√©duite
            height=24,  # Hauteur r√©duite
            font=("Arial", 11),  # Police plus petite
            fg_color="#FF5252",  # Rouge pour la d√©connexion
            hover_color="#FF1744"  # Rouge plus fonc√© au survol
        )
        logout_button.pack(side="right", padx=5)
		
        # Frame principale
        self.main_frame = ctk.CTkFrame(self.root)
        self.main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Tabview
        self.tabview = ctk.CTkTabview(self.main_frame)
        self.tabview.pack(padx=20, pady=20, fill="both", expand=True)

        # Cr√©ation des onglets
        tabs = [
            "Configuration √âcole",
            "Gestion des Frais",
            "Inscription √âl√®ves",
            "Suivi des Paiements",
            "Rapports"
        ]

        for tab_name in tabs:
            tab = self.tabview.add(tab_name)
            self.configure_tab(tab, tab_name)

    def configure_tab(self, tab, tab_name):
        # Configuration des onglets
        if tab_name == "Configuration √âcole":
            self.create_school_config_tab(tab)
        elif tab_name == "Gestion des Frais":
            self.create_fee_management_tab(tab)
        elif tab_name == "Inscription √âl√®ves":
            self.create_registration_tab(tab)
        elif tab_name == "Suivi des Paiements":
            self.create_payment_tracking_tab(tab)
        elif tab_name == "Rapports":
            self.create_reports_tab(tab)	

    def create_school_config_tab(self, tab):
        """Configuration de l'√©cole avec navigation"""
        
        # === TITRE PRINCIPAL ===
        self._create_header(tab)
        
        # === BARRE DE NAVIGATION ===
        self.school_config_tabview = ctk.CTkTabview(tab)
        self.school_config_tabview.pack(padx=20, pady=(0, 20), fill="both", expand=True)
        
        # Cr√©ation des onglets
        tabs = {
            "Informations G√©n√©rales": self._create_general_info_tab,
            "Param√®tres Avanc√©s": self._create_advanced_settings_tab,
            "Param√®tres de Notifications": self._create_notifications_tab
        }
        
        # Ajout des onglets
        for tab_name, create_func in tabs.items():
            tab_frame = self.school_config_tabview.add(tab_name)
            create_func(tab_frame)
        
        # === BOUTONS D'ACTION ===
        self.create_action_buttons(tab)
    
    def _create_header(self, parent):
        """Cr√©e l'en-t√™te de la configuration"""
        header_frame = ctk.CTkFrame(parent, fg_color="transparent")
        header_frame.pack(fill="x", padx=20, pady=20)
        
        # Titre principal
        ctk.CTkLabel(
            header_frame,
            text="Configuration de l'√âcole",
            font=("Arial", 24, "bold")
        ).pack(side="left")
        
        # Date de derni√®re modification
        self.last_modified_label = ctk.CTkLabel(
            header_frame,
            text="Derni√®re modification: Jamais",
            font=("Arial", 12)
        )
        self.last_modified_label.pack(side="right")
    
    def _create_general_info_tab(self, tab):
        """Cr√©e l'onglet des informations g√©n√©rales"""
        # Frame principal
        main_frame = ctk.CTkScrollableFrame(tab)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Informations de l'√©cole
        self.school_info = {}
        fields = [
            ("name", "Nom de l'√âcole*", "entry"),
            ("address", "Adresse*", "entry"),
            ("phone", "T√©l√©phone*", "entry"),
            ("email", "Email*", "entry"),
            ("website", "Site Web", "entry"),
            ("director", "Directeur*", "entry"),
            ("description", "Description", "text"),
            ("academic_year", "Ann√©e Acad√©mique*", "entry")
        ]
        
        for field_id, label, field_type in fields:
            self._create_field_with_style(main_frame, field_id, label, field_type)
    
    def _create_advanced_settings_tab(self, tab):
        """Cr√©e l'onglet des param√®tres avanc√©s"""
        # Frame principal avec scroll
        main_frame = ctk.CTkScrollableFrame(tab)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Section des trimestres
        self._create_term_section(main_frame)
        
        # S√©parateur
        self._create_separator(main_frame)
        
        # Section des vacances
        self._create_holiday_section(main_frame)
    
    def _create_notifications_tab(self, tab):
        """Cr√©e l'onglet des param√®tres de notification"""
        # Frame principal avec scroll
        main_frame = ctk.CTkScrollableFrame(tab)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Options de notification
        options = [
            ("payment_reminder", "Rappels de paiement", "Notifications pour les √©ch√©ances de paiement"),
            ("late_payment", "Retards de paiement", "Alertes pour les paiements en retard"),
            ("new_registration", "Nouvelles inscriptions", "Notifications des nouvelles inscriptions"),
            ("holiday_reminder", "Rappels de vacances", "Notifications des p√©riodes de vacances"),
            ("exam_reminder", "Rappels d'examens", "Notifications des dates d'examens"),
            ("attendance_alert", "Alertes d'assiduit√©", "Notifications des absences")
        ]
        
        self.notification_vars = {}
        for option_id, label, description in options:
            self._create_notification_option(main_frame, option_id, label, description)
    
    
    def _create_field_with_style(self, parent, field_id, label, field_type):
        """Cr√©e un champ stylis√© avec validation"""
        # Frame pour le champ
        field_frame = ctk.CTkFrame(parent, fg_color="transparent")
        field_frame.pack(fill="x", pady=5, padx=10)
        
        # Label avec indicateur si requis
        is_required = "*" in label
        label_color = "#FF6B6B" if is_required else "gray"
        
        label_frame = ctk.CTkFrame(field_frame, fg_color="transparent")
        label_frame.pack(side="left", padx=5)
        
        ctk.CTkLabel(
            label_frame,
            text=label.replace("*", ""),
            font=("Arial", 12),
            text_color=label_color
        ).pack(side="left")
    
        # Cr√©ation du widget selon le type
        if field_type == "entry":
            widget = ctk.CTkEntry(field_frame, width=250)
            widget.pack(side="right", padx=5)
            
            # Ajouter une validation en temps r√©el
            widget.bind('<KeyRelease>', lambda e: self._validate_field(field_id, widget))
            
        elif field_type == "text":
            widget = ctk.CTkTextbox(field_frame, height=100, width=250)
            widget.pack(side="right", padx=5)
            
        self.school_info[field_id] = widget
    
    def _create_term_section(self, parent):
        """Cr√©e la section des trimestres avec calendrier"""
        # Frame pour les trimestres
        term_frame = ctk.CTkFrame(parent)
        term_frame.pack(fill="x", pady=10, padx=10)
        
        # En-t√™te
        header_frame = ctk.CTkFrame(term_frame, fg_color="transparent")
        header_frame.pack(fill="x", pady=5)
        
        ctk.CTkLabel(
            header_frame,
            text="P√©riodes Scolaires",
            font=("Arial", 16, "bold")
        ).pack(side="left")
        
        self.terms_data = []
        terms = [
            ("Premier Trimestre", "Septembre", "D√©cembre"),
            ("Deuxi√®me Trimestre", "Janvier", "Mars"),
            ("Troisi√®me Trimestre", "Avril", "Juin")
        ]
        
        for term_name, default_start, default_end in terms:
            self._create_term_row(term_frame, term_name, default_start, default_end)
    
    def _create_term_row(self, parent, term_name, start_hint, end_hint):
        """Cr√©e une ligne de configuration de trimestre"""
        term_data = {}
        row_frame = ctk.CTkFrame(parent, fg_color="transparent")
        row_frame.pack(fill="x", pady=5)
        
        # Label du trimestre
        ctk.CTkLabel(
            row_frame,
            text=f"{term_name}:",
            font=("Arial", 12),
            width=150,
            anchor="w"
        ).pack(side="left", padx=5)
        
        # Frame pour les dates
        dates_frame = ctk.CTkFrame(row_frame, fg_color="transparent")
        dates_frame.pack(side="left", fill="x", expand=True)
        
        # Date de d√©but
        term_data['start'] = ctk.CTkEntry(
            dates_frame,
            width=120,
            placeholder_text=start_hint
        )
        term_data['start'].pack(side="left", padx=2)
        
        # S√©parateur visuel
        ctk.CTkLabel(
            dates_frame,
            text="‚Üí",
            font=("Arial", 12)
        ).pack(side="left", padx=5)
        
        # Date de fin
        term_data['end'] = ctk.CTkEntry(
            dates_frame,
            width=120,
            placeholder_text=end_hint
        )
        term_data['end'].pack(side="left", padx=2)
        
        self.terms_data.append(term_data)
        
    def _create_holiday_section(self, parent):
        """Cr√©e la section des vacances scolaires avec option de suppression"""
        holiday_frame = ctk.CTkFrame(parent)
        holiday_frame.pack(fill="x", pady=10, padx=10)
        
        # En-t√™te avec style
        header_frame = ctk.CTkFrame(holiday_frame, fg_color="transparent")
        header_frame.pack(fill="x", pady=5)
        
        ctk.CTkLabel(
            header_frame,
            text="P√©riodes de Vacances",
            font=("Arial", 16, "bold")
        ).pack(side="left")
        
        # Frame pour les boutons
        buttons_frame = ctk.CTkFrame(header_frame, fg_color="transparent")
        buttons_frame.pack(side="right")
        
        # Bouton supprimer
        delete_button = ctk.CTkButton(
            buttons_frame,
            text="üóëÔ∏è Supprimer",
            command=self.delete_holiday_period,
            width=100,
            height=32,
            fg_color="#E74C3C",
            hover_color="#C0392B"
        )
        delete_button.pack(side="right", padx=5)
        
        # Bouton d'ajout stylis√©
        add_button = ctk.CTkButton(
            buttons_frame,
            text="+ Ajouter",
            command=self.add_holiday_period,
            width=100,
            height=32,
            fg_color="#2ECC71",
            hover_color="#27AE60"
        )
        add_button.pack(side="right", padx=5)
        
        # Liste des vacances avec style
        style = ttk.Style()
        style.configure(
            "Holiday.Treeview",
            background="#2b2b2b",
            foreground="white",
            fieldbackground="#2b2b2b",
            rowheight=25
        )
        
        self.holiday_list = ttk.Treeview(
            holiday_frame,
            columns=("Nom", "D√©but", "Fin"),
            show="headings",
            style="Holiday.Treeview",
            height=6
        )
        
        # Configuration des colonnes
        for col in ("Nom", "D√©but", "Fin"):
            self.holiday_list.heading(col, text=col)
            self.holiday_list.column(col, width=120)
        
        self.holiday_list.pack(fill="x", pady=5)
        
        # Ajouter un √©v√©nement de s√©lection pour activer/d√©sactiver le bouton supprimer
        self.holiday_list.bind('<<TreeviewSelect>>', self._toggle_delete_button)
    
    def delete_holiday_period(self):
        """Supprime la p√©riode de vacances s√©lectionn√©e"""
        selected_item = self.holiday_list.selection()
        
        if not selected_item:
            self._show_error_message("Veuillez s√©lectionner une p√©riode √† supprimer")
            return
        
        # R√©cup√©rer les informations de la p√©riode s√©lectionn√©e
        item_values = self.holiday_list.item(selected_item[0])["values"]
        period_name = item_values[0]
        
        # Demander confirmation
        if self._show_confirmation_dialog(
            "Confirmation de suppression",
            f"√ätes-vous s√ªr de vouloir supprimer la p√©riode '{period_name}' ?"
        ):
            # Supprimer la p√©riode
            self.holiday_list.delete(selected_item)
            self._update_modification_status(False)
            self._show_success_message(f"La p√©riode '{period_name}' a √©t√© supprim√©e")
    
    def _toggle_delete_button(self, event):
        """Active ou d√©sactive le bouton supprimer selon la s√©lection"""
        # V√©rifier si une ligne est s√©lectionn√©e
        selected = len(self.holiday_list.selection()) > 0
        
        # Trouver le bouton supprimer dans la hi√©rarchie des widgets
        for widget in self.holiday_list.master.winfo_children():
            if isinstance(widget, ctk.CTkFrame):  # Header frame
                for child in widget.winfo_children():
                    if isinstance(child, ctk.CTkFrame):  # Buttons frame
                        for button in child.winfo_children():
                            if isinstance(button, ctk.CTkButton) and "Supprimer" in button._text:
                                # Mettre √† jour l'√©tat du bouton
                                button.configure(
                                    state="normal" if selected else "disabled",
                                    fg_color="#E74C3C" if selected else "#666666"
                                )
							
							
							
    
    def _create_notification_option(self, parent, option_id, label, description):
        """Cr√©e une option de notification stylis√©e"""
        option_frame = ctk.CTkFrame(parent)
        option_frame.pack(fill="x", pady=5, padx=5)
        
        # Frame gauche pour le switch et le label
        left_frame = ctk.CTkFrame(option_frame, fg_color="transparent")
        left_frame.pack(side="left", fill="x", expand=True)
        
        self.notification_vars[option_id] = ctk.BooleanVar(value=False)
        
        # Switch stylis√©
        switch = ctk.CTkSwitch(
            left_frame,
            text=label,
            variable=self.notification_vars[option_id],
            font=("Arial", 12, "bold")
        )
        switch.pack(side="left", padx=10)
        
        # Description
        desc_label = ctk.CTkLabel(
            left_frame,
            text=description,
            font=("Arial", 11),
            text_color="gray"
        )
        desc_label.pack(side="left", padx=10)
    
    def _create_separator(self, parent):
        """Cr√©e un s√©parateur visuel"""
        separator = ctk.CTkFrame(parent, height=2, fg_color="gray")
        separator.pack(fill="x", pady=10, padx=20)
    
    def _validate_field(self, field_id, widget):
        """Valide un champ en temps r√©el"""
        value = widget.get()
        is_valid = True
        
        if field_id == "email" and value:
            is_valid = "@" in value and "." in value
        elif field_id == "phone" and value:
            is_valid = value.replace(" ", "").isdigit()
        
        # Mise √† jour visuelle selon la validation
        widget.configure(
            border_color="green" if is_valid else "red"
        )
    
    
    def create_action_buttons(self, parent):
        """Cr√©e la barre d'actions avec style et animations"""
        # Frame principale pour les actions
        action_frame = ctk.CTkFrame(parent, fg_color="transparent")
        action_frame.pack(fill="x", pady=20, padx=20)
        
        # Frame pour le statut
        status_frame = ctk.CTkFrame(action_frame, fg_color="transparent")
        status_frame.pack(fill="x", pady=(0, 10))
        
        # Indicateur de modification
        self.modification_label = ctk.CTkLabel(
            status_frame,
            text="‚úì Tous les changements sont sauvegard√©s",
            font=("Arial", 12),
            text_color="green"
        )
        self.modification_label.pack(side="right")
    
        # Frame pour les boutons
        buttons_frame = ctk.CTkFrame(action_frame, fg_color="transparent")
        buttons_frame.pack(fill="x")
        
        # Configuration des boutons
        buttons = [
            {
                "text": "Sauvegarder",
                "icon": "üíæ",
                "color": "#2ECC71",
                "hover_color": "#27AE60",
                "command": self.save_school_config
            },
            {
                "text": "R√©initialiser",
                "icon": "üîÑ",
                "color": "#E74C3C",
                "hover_color": "#C0392B",
                "command": self.reset_school_config
            },
            {
                "text": "Exporter",
                "icon": "üì§",
                "color": "#3498DB",
                "hover_color": "#2980B9",
                "command": self.export_school_config
            },
            {
                "text": "Importer",
                "icon": "üì•",
                "color": "#3498DB",
                "hover_color": "#2980B9",
                "command": self.import_school_config
            }
        ]
        
        # Cr√©ation des boutons
        for btn in buttons:
            self._create_styled_button(buttons_frame, **btn)
    
    def _create_styled_button(self, parent, text, icon, color, hover_color, command):
        button = ctk.CTkButton(
            parent,
            text=f"{icon} {text}",
            command=command,
            fg_color=color,
            hover_color=hover_color,
            width=150,
            height=35,
            corner_radius=8,
            font=("Arial", 13)
        )
        button.pack(side="left", padx=10, expand=True)
			
			
    def _show_confirmation_dialog(self, title, message):
        """Affiche une bo√Æte de dialogue de confirmation personnalis√©e"""
        dialog = ctk.CTkToplevel(self.root)
        dialog.title(title)
        dialog.geometry("400x200")
        dialog.transient(self.root)
        dialog.grab_set()
        
        result = {"value": False}
        
        # Message
        ctk.CTkLabel(
            dialog,
            text=message,
            font=("Arial", 12),
            wraplength=350
        ).pack(pady=20)
        
        # Boutons
        buttons_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        buttons_frame.pack(pady=20)
        
        ctk.CTkButton(
            buttons_frame,
            text="Confirmer",
            fg_color="#2ECC71",
            hover_color="#27AE60",
            command=lambda: self._close_dialog(dialog, result, True)
        ).pack(side="left", padx=10)
        
        ctk.CTkButton(
            buttons_frame,
            text="Annuler",
            fg_color="#E74C3C",
            hover_color="#C0392B",
            command=lambda: self._close_dialog(dialog, result, False)
        ).pack(side="left", padx=10)
        
        dialog.wait_window()
        return result["value"]
    
    def _close_dialog(self, dialog, result, value):
        """Ferme la bo√Æte de dialogue et d√©finit le r√©sultat"""
        result["value"] = value
        dialog.destroy()
    
    def _show_success_message(self, message):
        """Affiche un message de succ√®s stylis√©"""
        CTkMessagebox(
            title="Succ√®s",
            message=message,
            icon="check",
            font=("Arial", 12),
            fade_in_duration=300
        )
    
    def _show_error_message(self, message):
        """Affiche un message d'erreur stylis√©"""
        CTkMessagebox(
            title="Erreur",
            message=message,
            icon="cancel",
            font=("Arial", 12),
            fade_in_duration=300
        )
    
    def _update_modification_status(self, is_saved=True):
        """Met √† jour l'indicateur de modification"""
        if is_saved:
            self.modification_label.configure(
                text="‚úì Tous les changements sont sauvegard√©s",
                text_color="green"
            )
        else:
            self.modification_label.configure(
                text="‚ö† Modifications non sauvegard√©es",
                text_color="orange"
            )
    
    def save_school_config(self):
        """Sauvegarde la configuration avec animations et retours visuels"""
        try:
            if not self._validate_all_fields():
                return
            
            # Animation de sauvegarde
            self.modification_label.configure(text="üíæ Sauvegarde en cours...")
            self.root.update()
            
            # Sauvegarde des donn√©es
            self._save_school_data()
            self._save_terms_data()
            self._save_holidays_data()
            self._save_notifications_data()
            
            # Mise √† jour du statut
            self._update_modification_status(True)
            self._show_success_message("Configuration sauvegard√©e avec succ√®s!")
            
        except Exception as e:
            self._show_error_message(f"Erreur lors de la sauvegarde: {str(e)}")

    def add_holiday_period(self):
        """Ajoute une nouvelle p√©riode de vacances avec une interface am√©lior√©e"""
        dialog = ctk.CTkToplevel(self.root)
        dialog.title("Ajouter une p√©riode de vacances")
        dialog.geometry("500x300")
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Frame principal
        main_frame = ctk.CTkFrame(dialog)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Titre
        ctk.CTkLabel(
            main_frame,
            text="Nouvelle p√©riode de vacances",
            font=("Arial", 16, "bold")
        ).pack(pady=10)
        
        # Variables pour stocker les valeurs
        fields = {
            "name": {"label": "Nom de la p√©riode", "var": ctk.StringVar()},
            "start_date": {"label": "Date de d√©but", "var": ctk.StringVar()},
            "end_date": {"label": "Date de fin", "var": ctk.StringVar()}
        }
        
        # Cr√©ation des champs
        for field_id, field_info in fields.items():
            frame = ctk.CTkFrame(main_frame, fg_color="transparent")
            frame.pack(fill="x", pady=5)
            
            ctk.CTkLabel(
                frame,
                text=field_info["label"] + ":",
                font=("Arial", 12)
            ).pack(side="left", padx=5)
            
            entry = ctk.CTkEntry(frame, width=200, textvariable=field_info["var"])
            entry.pack(side="right", padx=5)
            
            # Ajouter un placeholder
            entry.insert(0, "")
            fields[field_id]["entry"] = entry
        
        def validate_and_save():
            """Valide et sauvegarde la p√©riode de vacances"""
            # V√©rification des champs requis
            if not all(field_info["var"].get().strip() for field_info in fields.values()):
                self._show_error_message("Tous les champs sont requis!")
                return
            
            # Ajout dans le treeview
            self.holiday_list.insert("", "end", values=(
                fields["name"]["var"].get(),
                fields["start_date"]["var"].get(),
                fields["end_date"]["var"].get()
            ))
            
            dialog.destroy()
            self._update_modification_status(False)
        
        def cancel():
            """Ferme la fen√™tre"""
            dialog.destroy()
        
        # Frame pour les boutons
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack(fill="x", pady=20)
        
        # Bouton Sauvegarder
        ctk.CTkButton(
            button_frame,
            text="Sauvegarder",
            command=validate_and_save,
            fg_color="#2ECC71",
            hover_color="#27AE60",
            width=120
        ).pack(side="left", padx=10, expand=True)
        
        # Bouton Annuler
        ctk.CTkButton(
            button_frame,
            text="Annuler",
            command=cancel,
            fg_color="#E74C3C",
            hover_color="#C0392B",
            width=120
        ).pack(side="right", padx=10, expand=True)
        
        # Centrer la fen√™tre
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry(f"{width}x{height}+{x}+{y}")
	
	
    
    def reset_school_config(self):
        """R√©initialise la configuration avec confirmation et animation"""
        # Demander confirmation
        if not self._show_confirmation_dialog(
            "Confirmation de r√©initialisation",
            "√ätes-vous s√ªr de vouloir r√©initialiser tous les champs ? Cette action ne peut pas √™tre annul√©e."
        ):
            return
    
        try:
            # Animation de r√©initialisation
            self.modification_label.configure(
                text="üîÑ R√©initialisation en cours...",
                text_color="orange"
            )
            self.root.update()
            
            # R√©initialiser les champs d'information de l'√©cole
            for widget in self.school_info.values():
                if isinstance(widget, ctk.CTkEntry):
                    widget.delete(0, 'end')
                elif isinstance(widget, ctk.CTkTextbox):
                    widget.delete('1.0', 'end')
            
            # R√©initialiser les trimestres
            for term in self.terms_data:
                for field in ['start', 'end']:
                    term[field].delete(0, 'end')
            
            # R√©initialiser les vacances
            for item in self.holiday_list.get_children():
                self.holiday_list.delete(item)
            
            # R√©initialiser les notifications
            for var in self.notification_vars.values():
                var.set(False)
            
            # Petite pause pour l'animation
            self.root.after(500)
            
            # Mise √† jour du statut
            self._update_modification_status(True)
            
            # Message de succ√®s
            self._show_success_message(
                "Tous les champs ont √©t√© r√©initialis√©s avec succ√®s!"
            )
            
        except Exception as e:
            self._show_error_message(
                f"Une erreur s'est produite lors de la r√©initialisation: {str(e)}"
            )
    
    def _show_confirmation_dialog(self, title, message):
        """Affiche une bo√Æte de dialogue de confirmation personnalis√©e"""
        dialog = ctk.CTkToplevel(self.root)
        dialog.title(title)
        dialog.geometry("400x200")
        dialog.transient(self.root)
        dialog.grab_set()
        
        result = {"value": False}
        
        # Message
        ctk.CTkLabel(
            dialog,
            text=message,
            font=("Arial", 12),
            wraplength=350
        ).pack(pady=20)
        
        # Boutons
        buttons_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        buttons_frame.pack(pady=20)
        
        ctk.CTkButton(
            buttons_frame,
            text="Confirmer",
            fg_color="#2ECC71",
            hover_color="#27AE60",
            command=lambda: self._close_dialog(dialog, result, True)
        ).pack(side="left", padx=10)
        
        ctk.CTkButton(
            buttons_frame,
            text="Annuler",
            fg_color="#E74C3C",
            hover_color="#C0392B",
            command=lambda: self._close_dialog(dialog, result, False)
        ).pack(side="left", padx=10)
        
        # Centrer la fen√™tre
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry(f"{width}x{height}+{x}+{y}")
        
        dialog.wait_window()
        return result["value"]
    
    def _close_dialog(self, dialog, result, value):
        """Ferme la bo√Æte de dialogue et d√©finit le r√©sultat"""
        result["value"] = value
        dialog.destroy()
	
    def export_school_config(self):
        """Exporte la configuration de l'√©cole avec interface am√©lior√©e"""
        try:
            # Pr√©parer les donn√©es √† exporter
            config_data = self._prepare_export_data()
            
            # Ouvrir dialogue de sauvegarde
            file_path = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[
                    ("Fichier JSON", "*.json"),
                    ("Tous les fichiers", "*.*")
                ],
                title="Exporter la configuration",
                initialfile=f"config_ecole_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            )
            
            if not file_path:
                return
            
            # Animation d'export
            self.modification_label.configure(
                text="üì§ Exportation en cours...",
                text_color="orange"
            )
            self.root.update()
            
            # Sauvegarder les donn√©es
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, indent=4, ensure_ascii=False)
            
            # Message de succ√®s
            self._show_success_message(
                f"Configuration export√©e avec succ√®s!\nFichier: {os.path.basename(file_path)}"
            )
            
        except Exception as e:
            self._show_error_message(f"Erreur lors de l'exportation: {str(e)}")
    
    def _prepare_export_data(self):
        """Pr√©pare les donn√©es pour l'exportation"""
        config_data = {
            "metadata": {
                "export_date": datetime.now().isoformat(),
                "version": "1.0"
            },
            "school_info": {},
            "terms": [],
            "holidays": [],
            "notifications": {}
        }
        
        # Informations de l'√©cole
        for field_id, widget in self.school_info.items():
            if isinstance(widget, ctk.CTkEntry):
                value = widget.get()
            elif isinstance(widget, ctk.CTkTextbox):
                value = widget.get("1.0", "end-1c")
            config_data["school_info"][field_id] = value
        
        # Donn√©es des trimestres
        for term in self.terms_data:
            config_data["terms"].append({
                "start": term["start"].get(),
                "end": term["end"].get()
            })
        
        # Donn√©es des vacances
        for item in self.holiday_list.get_children():
            values = self.holiday_list.item(item)["values"]
            config_data["holidays"].append({
                "name": values[0],
                "start_date": values[1],
                "end_date": values[2]
            })
        
        # Configuration des notifications
        for option_id, var in self.notification_vars.items():
            config_data["notifications"][option_id] = var.get()
        
        return config_data
    
    def import_school_config(self):
        """Importe la configuration de l'√©cole"""
        try:
            # Ouvrir dialogue de s√©lection de fichier
            file_path = filedialog.askopenfilename(
                filetypes=[
                    ("Fichier JSON", "*.json"),
                    ("Tous les fichiers", "*.*")
                ],
                title="Importer la configuration"
            )
            
            if not file_path:
                return
            
            # Demander confirmation
            if not self._show_confirmation_dialog(
                "Confirmation d'importation",
                "L'importation √©crasera la configuration actuelle. Voulez-vous continuer ?"
            ):
                return
            
            # Animation d'importation
            self.modification_label.configure(
                text="üì• Importation en cours...",
                text_color="orange"
            )
            self.root.update()
            
            # Charger les donn√©es
            with open(file_path, 'r', encoding='utf-8') as f:
                config_data = json.load(f)
            
            # R√©initialiser d'abord tous les champs
            self.reset_school_config()
            
            # Appliquer les donn√©es import√©es
            self._apply_imported_data(config_data)
            
            # Message de succ√®s
            self._show_success_message(
                "Configuration import√©e avec succ√®s!"
            )
            
        except json.JSONDecodeError:
            self._show_error_message("Le fichier s√©lectionn√© n'est pas un fichier JSON valide")
        except Exception as e:
            self._show_error_message(f"Erreur lors de l'importation: {str(e)}")
    
    def _apply_imported_data(self, config_data):
        """Applique les donn√©es import√©es aux champs"""
        # Informations de l'√©cole
        for field_id, value in config_data.get("school_info", {}).items():
            if field_id in self.school_info:
                widget = self.school_info[field_id]
                if isinstance(widget, ctk.CTkEntry):
                    widget.delete(0, 'end')
                    widget.insert(0, value)
                elif isinstance(widget, ctk.CTkTextbox):
                    widget.delete('1.0', 'end')
                    widget.insert('1.0', value)
        
        # Trimestres
        for i, term_data in enumerate(config_data.get("terms", [])):
            if i < len(self.terms_data):
                self.terms_data[i]["start"].delete(0, 'end')
                self.terms_data[i]["start"].insert(0, term_data["start"])
                self.terms_data[i]["end"].delete(0, 'end')
                self.terms_data[i]["end"].insert(0, term_data["end"])
        
        # Vacances
        for holiday in config_data.get("holidays", []):
            self.holiday_list.insert("", "end", values=(
                holiday["name"],
                holiday["start_date"],
                holiday["end_date"]
            ))
        
        # Notifications
        for option_id, enabled in config_data.get("notifications", {}).items():
            if option_id in self.notification_vars:
                self.notification_vars[option_id].set(enabled)


    def _validate_all_fields(self):
        """Valide tous les champs du formulaire"""
        # Dictionnaire pour stocker les erreurs
        errors = []
        
        # Valider les informations de l'√©cole
        required_fields = {
            "name": "Nom de l'√âcole",
            "address": "Adresse",
            "phone": "T√©l√©phone",
            "email": "Email",
            "director": "Directeur",
            "academic_year": "Ann√©e Acad√©mique"
        }
        
        for field_id, field_name in required_fields.items():
            if field_id in self.school_info:
                widget = self.school_info[field_id]
                value = widget.get() if isinstance(widget, ctk.CTkEntry) else widget.get("1.0", "end-1c")
                
                if not value.strip():
                    errors.append(f"Le champ '{field_name}' est obligatoire")
                    widget.configure(border_color="red")
                else:
                    widget.configure(border_color="gray")
                    
                    # Validations sp√©cifiques
                    if field_id == "email" and not self._validate_email(value):
                        errors.append("L'adresse email n'est pas valide")
                        widget.configure(border_color="red")
                    
                    elif field_id == "phone" and not self._validate_phone(value):
                        errors.append("Le num√©ro de t√©l√©phone n'est pas valide")
                        widget.configure(border_color="red")
        
        # Valider les trimestres
        for i, term in enumerate(self.terms_data, 1):
            start_date = term["start"].get().strip()
            end_date = term["end"].get().strip()
            
            if not start_date or not end_date:
                errors.append(f"Les dates du trimestre {i} sont incompl√®tes")
                term["start"].configure(border_color="red" if not start_date else "gray")
                term["end"].configure(border_color="red" if not end_date else "gray")
            elif not self._validate_dates(start_date, end_date):
                errors.append(f"Les dates du trimestre {i} sont invalides")
                term["start"].configure(border_color="red")
                term["end"].configure(border_color="red")
            else:
                term["start"].configure(border_color="gray")
                term["end"].configure(border_color="gray")
        
        # Valider les p√©riodes de vacances
        holidays = []
        for item in self.holiday_list.get_children():
            values = self.holiday_list.item(item)["values"]
            if values:
                holidays.append({
                    "name": values[0],
                    "start": values[1],
                    "end": values[2]
                })
        
        for holiday in holidays:
            if not all(holiday.values()):
                errors.append(f"La p√©riode de vacances '{holiday['name']}' est incompl√®te")
            elif not self._validate_dates(holiday["start"], holiday["end"]):
                errors.append(f"Les dates de la p√©riode '{holiday['name']}' sont invalides")
        
        # Afficher les erreurs s'il y en a
        if errors:
            error_message = "\n".join([f"‚Ä¢ {error}" for error in errors])
            self._show_error_message(
                "Veuillez corriger les erreurs suivantes:\n\n" + error_message
            )
            return False
        
        return True
    
    def _validate_email(self, email):
        """Valide le format de l'adresse email"""
        import re
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None
    
    def _validate_phone(self, phone):
        """Valide le format du num√©ro de t√©l√©phone"""
        # Supprimer les espaces et tirets
        phone = phone.replace(" ", "").replace("-", "")
        # V√©rifier si c'est un num√©ro valide (ajustez selon vos besoins)
        return phone.isdigit() and 8 <= len(phone) <= 15
    
    def _validate_dates(self, start_date, end_date):
        """Valide les dates et leur ordre"""
        try:
            # Convertir les dates en objets datetime
            start = datetime.strptime(start_date, "%d/%m/%Y")
            end = datetime.strptime(end_date, "%d/%m/%Y")
            
            # V√©rifier que la date de fin est apr√®s la date de d√©but
            return end >= start
        except ValueError:
            return False
    
    def _show_validation_error(self, message):
        """Affiche une erreur de validation avec style"""
        dialog = ctk.CTkToplevel(self.root)
        dialog.title("Erreur de validation")
        dialog.geometry("500x400")
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Frame principal
        main_frame = ctk.CTkScrollableFrame(dialog)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Ic√¥ne d'erreur
        ctk.CTkLabel(
            main_frame,
            text="‚ö†Ô∏è",
            font=("Arial", 48)
        ).pack(pady=10)
        
        # Message d'erreur
        ctk.CTkLabel(
            main_frame,
            text=message,
            font=("Arial", 12),
            wraplength=400,
            justify="left"
        ).pack(pady=20)
        
        # Bouton OK
        ctk.CTkButton(
            main_frame,
            text="OK",
            command=dialog.destroy,
            width=100
        ).pack(pady=10)
        
        # Centrer la fen√™tre
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry(f"{width}x{height}+{x}+{y}")


    def _get_current_user(self):
        """R√©cup√®re les informations de l'utilisateur actuel"""
        return {
            'login': 'elmehdi-mfd',
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
    
    def _save_school_data(self):
        """Sauvegarde les informations de l'√©cole dans la base de donn√©es"""
        try:
            cursor = self.conn.cursor()
            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # R√©cup√©rer les donn√©es du formulaire
            school_data = {}
            for field_id, widget in self.school_info.items():
                if isinstance(widget, ctk.CTkEntry):
                    school_data[field_id] = widget.get()
                elif isinstance(widget, ctk.CTkTextbox):
                    school_data[field_id] = widget.get("1.0", "end-1c")
            
            # Mise √† jour de la table School
            cursor.execute("""
                INSERT OR REPLACE INTO School (
                    id, name, address, phone, email, website, 
                    director, logo_path, description, academic_year,
                    last_updated, modified_by, modified_at
                ) VALUES (
                    1, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                    ?, 'elmehdi-mfd', ?
                )
            """, (
                school_data.get("name", ""),
                school_data.get("address", ""),
                school_data.get("phone", ""),
                school_data.get("email", ""),
                school_data.get("website", ""),
                school_data.get("director", ""),
                school_data.get("logo_path", ""),
                school_data.get("description", ""),
                school_data.get("academic_year", ""),
                current_time,
                current_time
            ))
            
            self.conn.commit()
            
        except sqlite3.Error as e:
            raise Exception(f"Erreur lors de la sauvegarde des donn√©es de l'√©cole: {str(e)}")
    
    def _save_terms_data(self):
        """Sauvegarde les donn√©es des trimestres"""
        try:
            cursor = self.conn.cursor()
            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Supprimer les anciennes donn√©es
            cursor.execute("DELETE FROM SchoolTerms")
            
            # Ins√©rer les nouvelles donn√©es
            for i, term in enumerate(self.terms_data, 1):
                start_date = term["start"].get().strip()
                end_date = term["end"].get().strip()
                
                if start_date and end_date:  # Ne sauvegarder que si les deux dates sont remplies
                    cursor.execute("""
                        INSERT INTO SchoolTerms (
                            term_number, start_date, end_date,
                            created_by, created_at, modified_by, modified_at
                        ) VALUES (?, ?, ?, 'elmehdi-mfd', ?, 'elmehdi-mfd', ?)
                    """, (i, start_date, end_date, current_time, current_time))
            
            self.conn.commit()
            
        except sqlite3.Error as e:
            raise Exception(f"Erreur lors de la sauvegarde des trimestres: {str(e)}")
    
    def _save_holidays_data(self):
        """Sauvegarde les donn√©es des vacances"""
        try:
            cursor = self.conn.cursor()
            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Supprimer les anciennes donn√©es
            cursor.execute("DELETE FROM SchoolHolidays")
            
            # Ins√©rer les nouvelles donn√©es
            for item in self.holiday_list.get_children():
                values = self.holiday_list.item(item)["values"]
                if values and all(values):  # V√©rifier que toutes les valeurs sont pr√©sentes
                    cursor.execute("""
                        INSERT INTO SchoolHolidays (
                            name, start_date, end_date,
                            created_by, created_at, modified_by, modified_at
                        ) VALUES (?, ?, ?, 'elmehdi-mfd', ?, 'elmehdi-mfd', ?)
                    """, (*values, current_time, current_time))
            
            self.conn.commit()
            
        except sqlite3.Error as e:
            raise Exception(f"Erreur lors de la sauvegarde des vacances: {str(e)}")
    
    def _save_notifications_data(self):
        """Sauvegarde les param√®tres de notification"""
        try:
            cursor = self.conn.cursor()
            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Supprimer les anciennes donn√©es
            cursor.execute("DELETE FROM NotificationSettings")
            
            # Ins√©rer les nouvelles donn√©es
            for option_id, var in self.notification_vars.items():
                cursor.execute("""
                    INSERT INTO NotificationSettings (
                        notification_type, enabled,
                        created_by, created_at, modified_by, modified_at
                    ) VALUES (?, ?, 'elmehdi-mfd', ?, 'elmehdi-mfd', ?)
                """, (option_id, var.get(), current_time, current_time))
            
            self.conn.commit()
            
        except sqlite3.Error as e:
            raise Exception(f"Erreur lors de la sauvegarde des param√®tres de notification: {str(e)}")
		
		
		
    
    def _save_terms_data(self):
        """Sauvegarde les donn√©es des trimestres"""
        try:
            cursor = self.conn.cursor()
            
            # Supprimer les anciennes donn√©es
            cursor.execute("DELETE FROM SchoolTerms")
            
            # Ins√©rer les nouvelles donn√©es
            for i, term in enumerate(self.terms_data, 1):
                start_date = term["start"].get().strip()
                end_date = term["end"].get().strip()
                
                if start_date and end_date:  # Ne sauvegarder que si les deux dates sont remplies
                    cursor.execute("""
                        INSERT INTO SchoolTerms (
                            term_number, start_date, end_date
                        ) VALUES (?, ?, ?)
                    """, (i, start_date, end_date))
            
            self.conn.commit()
            
        except sqlite3.Error as e:
            raise Exception(f"Erreur lors de la sauvegarde des trimestres: {str(e)}")
    
    def _save_holidays_data(self):
        """Sauvegarde les donn√©es des vacances"""
        try:
            cursor = self.conn.cursor()
            
            # Supprimer les anciennes donn√©es
            cursor.execute("DELETE FROM SchoolHolidays")
            
            # Ins√©rer les nouvelles donn√©es
            for item in self.holiday_list.get_children():
                values = self.holiday_list.item(item)["values"]
                if values and all(values):  # V√©rifier que toutes les valeurs sont pr√©sentes
                    cursor.execute("""
                        INSERT INTO SchoolHolidays (
                            name, start_date, end_date
                        ) VALUES (?, ?, ?)
                    """, values)
            
            self.conn.commit()
            
        except sqlite3.Error as e:
            raise Exception(f"Erreur lors de la sauvegarde des vacances: {str(e)}")
    
    def _save_notifications_data(self):
        """Sauvegarde les param√®tres de notification"""
        try:
            cursor = self.conn.cursor()
            
            # Supprimer les anciennes donn√©es
            cursor.execute("DELETE FROM NotificationSettings")
            
            # Ins√©rer les nouvelles donn√©es
            for option_id, var in self.notification_vars.items():
                cursor.execute("""
                    INSERT INTO NotificationSettings (
                        notification_type, enabled
                    ) VALUES (?, ?)
                """, (option_id, var.get()))
            
            self.conn.commit()
            
        except sqlite3.Error as e:
            raise Exception(f"Erreur lors de la sauvegarde des param√®tres de notification: {str(e)}")
    
    def _load_saved_data(self):
        """Charge les donn√©es sauvegard√©es depuis la base de donn√©es"""
        try:
            cursor = self.conn.cursor()
            
            # Charger les informations de l'√©cole
            cursor.execute("SELECT * FROM School WHERE id = 1")
            school_data = cursor.fetchone()
            if school_data:
                fields = [
                    "name", "address", "phone", "email", "website",
                    "director", "logo_path", "description", "academic_year"
                ]
                for i, field in enumerate(fields, 1):
                    if field in self.school_info:
                        widget = self.school_info[field]
                        if isinstance(widget, ctk.CTkEntry):
                            widget.delete(0, 'end')
                            widget.insert(0, school_data[i] or "")
                        elif isinstance(widget, ctk.CTkTextbox):
                            widget.delete('1.0', 'end')
                            widget.insert('1.0', school_data[i] or "")
            
            # Charger les trimestres
            cursor.execute("SELECT * FROM SchoolTerms ORDER BY term_number")
            terms_data = cursor.fetchall()
            for i, term_data in enumerate(terms_data):
                if i < len(self.terms_data):
                    self.terms_data[i]["start"].delete(0, 'end')
                    self.terms_data[i]["start"].insert(0, term_data[1])
                    self.terms_data[i]["end"].delete(0, 'end')
                    self.terms_data[i]["end"].insert(0, term_data[2])
            
            # Charger les vacances
            cursor.execute("SELECT name, start_date, end_date FROM SchoolHolidays")
            for holiday in cursor.fetchall():
                self.holiday_list.insert("", "end", values=holiday)
            
            # Charger les param√®tres de notification
            cursor.execute("SELECT notification_type, enabled FROM NotificationSettings")
            for notification_type, enabled in cursor.fetchall():
                if notification_type in self.notification_vars:
                    self.notification_vars[notification_type].set(enabled)
                    
        except sqlite3.Error as e:
            self._show_error_message(f"Erreur lors du chargement des donn√©es: {str(e)}")


		
	




	
				
				
				
			
		
    def create_fee_management_tab(self, tab):
        # Gestion des frais
        ctk.CTkLabel(tab, text="Gestion des Frais Scolaires", font=("Arial", 20)).pack(pady=20)
    
        self.fee_tabview = ctk.CTkTabview(tab)
        self.fee_tabview.pack(padx=10, pady=10, fill="both", expand=True)
    
        # Onglets pour les diff√©rents niveaux
        levels = ["Primary", "College", "High School"]
        for level in levels:
            fee_tab = self.fee_tabview.add(level)
            self.configure_fee_tab(fee_tab, level)
    def add_subject(self):
        level = self.level_var.get()
        subject_name = self.subject_entry.get().strip()
        fee = self.fee_var.get()
        
        if not subject_name:
            CTkMessagebox(title="Erreur", message="Veuillez entrer un nom de mati√®re", icon="cancel")
            return
        
        try:
            fee_float = float(fee)
            cursor = self.conn.cursor()
            
            # V√©rifier si la mati√®re existe d√©j√†
            cursor.execute("""
                SELECT COUNT(*) FROM Subjects 
                WHERE level = ? AND name = ?
            """, (level, subject_name))
            
            if cursor.fetchone()[0] > 0:
                CTkMessagebox(title="Erreur", 
                             message="Cette mati√®re existe d√©j√† pour ce niveau", 
                             icon="cancel")
                return
        
            # Ins√©rer la nouvelle mati√®re
            cursor.execute("""
                INSERT INTO Subjects (level, name, fee) 
                VALUES (?, ?, ?)
            """, (level, subject_name, fee_float))
            
            self.conn.commit()
            
            print(f"Mati√®re ajout√©e avec succ√®s: {level} - {subject_name} - {fee_float}")
            
            # Mettre √† jour l'affichage
            self.update_subjects_list()
            
            # Vider les champs
            self.subject_entry.delete(0, 'end')
            self.fee_var.set("0.0")
            
            CTkMessagebox(title="Succ√®s", 
                         message="Mati√®re ajout√©e avec succ√®s", 
                         icon="check")
            
        except ValueError:
            CTkMessagebox(title="Erreur", 
                         message="Le montant doit √™tre un nombre valide", 
                         icon="cancel")
        except sqlite3.Error as e:
            CTkMessagebox(title="Erreur", 
                         message=f"Erreur lors de l'ajout de la mati√®re: {str(e)}", 
                         icon="cancel")
    def configure_fee_tab(self, tab, level):
        if level == "Primary":
            self.create_primary_fee_tab(tab)
        elif level == "College":
            self.create_college_fee_tab(tab)
        elif level == "High School":
            self.create_high_school_fee_tab(tab)

    def create_primary_fee_tab(self, tab):
        # Frais pour le niveau primaire
        ctk.CTkLabel(tab, text="Frais pour le Niveau Primaire", font=("Arial", 20)).pack(pady=20)
        
        ctk.CTkLabel(tab, text="Montant des Frais").pack(pady=5)
        self.primary_fee_entry = ctk.CTkEntry(tab, width=300)
        self.primary_fee_entry.pack(pady=5)
        
        save_primary_fee_button = ctk.CTkButton(
            tab,
            text="Enregistrer Frais",
            command=self.save_primary_fee
        )
        save_primary_fee_button.pack(pady=20)

    def save_primary_fee(self):
        # Logique de sauvegarde des frais primaires
        try:
            self.primary_amount = float(self.primary_fee_entry.get())
            cursor = self.conn.cursor()
            cursor.execute("INSERT OR REPLACE INTO FeeConfiguration (level, amount) VALUES (?, ?)", ("Primary", self.primary_amount))
            self.conn.commit()
            CTkMessagebox(title="Succ√®s", message="Frais primaires enregistr√©s", icon="check")
        except ValueError:
            CTkMessagebox(title="Erreur", message="Montant invalide", icon="cancel")

    def create_college_fee_tab(self, tab):
        # Frais pour le niveau coll√®ge
        ctk.CTkLabel(tab, text="Frais pour le Niveau Coll√®ge", font=("Arial", 20)).pack(pady=20)
        
        ctk.CTkLabel(tab, text="Nom de la Mati√®re").pack(pady=5)
        self.college_subject_entry = ctk.CTkEntry(tab, width=300)
        self.college_subject_entry.pack(pady=5)
        
        ctk.CTkLabel(tab, text="Frais de la Mati√®re").pack(pady=5)
        self.college_fee_entry = ctk.CTkEntry(tab, width=300)
        self.college_fee_entry.pack(pady=5)
        
        add_subject_button = ctk.CTkButton(
            tab,
            text="Ajouter Mati√®re",
            command=self.add_college_subject
        )
        add_subject_button.pack(pady=20)
        
        # Cr√©ation du Treeview pour le niveau coll√®ge
        self.college_subjects_treeview = self.create_subjects_treeview(tab)
        self.update_subjects_treeview("College")

    def add_college_subject(self):
        subject = self.college_subject_entry.get()
        fee = self.college_fee_entry.get()
        
        # V√©rification si les champs sont valides
        if subject and fee:
            try:
                fee = float(fee)
                cursor = self.conn.cursor()
                # Ajouter la mati√®re et le frais √† la base de donn√©es
                cursor.execute("INSERT INTO Subjects (level, name, fee) VALUES (?, ?, ?)", ("College", subject, fee))
                self.conn.commit()
                
                # Mise √† jour du Treeview avec la nouvelle mati√®re et frais
                self.update_subjects_treeview("College")
                
                # R√©initialisation des champs
                self.college_subject_entry.delete(0, 'end')
                self.college_fee_entry.delete(0, 'end')
                
                CTkMessagebox(title="Succ√®s", message="Mati√®re ajout√©e avec succ√®s", icon="check")
            except ValueError:
                CTkMessagebox(title="Erreur", message="Veuillez entrer un montant valide pour les frais", icon="cancel")
        else:
            CTkMessagebox(title="Erreur", message="Veuillez remplir tous les champs", icon="cancel")

    def create_high_school_fee_tab(self, tab):
        # Frais pour le niveau lyc√©e
        ctk.CTkLabel(tab, text="Frais pour le Niveau Lyc√©e", font=("Arial", 20)).pack(pady=20)
        
        ctk.CTkLabel(tab, text="Nom de la Mati√®re").pack(pady=5)
        self.high_school_subject_entry = ctk.CTkEntry(tab, width=300)
        self.high_school_subject_entry.pack(pady=5)
        
        ctk.CTkLabel(tab, text="Frais de la Mati√®re").pack(pady=5)
        self.high_school_fee_entry = ctk.CTkEntry(tab, width=300)
        self.high_school_fee_entry.pack(pady=5)
        
        add_subject_button = ctk.CTkButton(
            tab,
            text="Ajouter Mati√®re",
            command=self.add_high_school_subject
        )
        add_subject_button.pack(pady=20)
        
        # Cr√©ation du Treeview pour le niveau lyc√©e
        self.high_school_subjects_treeview = self.create_subjects_treeview(tab)
        self.update_subjects_treeview("High School")

    def add_high_school_subject(self):
        # Ajout d'une mati√®re et de ses frais pour le lyc√©e
        subject_name = self.high_school_subject_entry.get().strip()  # R√©cup√®re le nom de la mati√®re
        try:
            fee_amount = float(self.high_school_fee_entry.get())  # R√©cup√®re le montant des frais
            cursor = self.conn.cursor()
            cursor.execute("INSERT INTO Subjects (level, name, fee) VALUES (?, ?, ?)", ('High School', subject_name, fee_amount))
            self.conn.commit()
            self.update_subjects_treeview("High School")  # Met √† jour le TreeView pour le lyc√©e avec l'argument "High School"
            self.high_school_subject_entry.delete(0, 'end')  # Efface le champ de saisie
            self.high_school_fee_entry.delete(0, 'end')  # Efface le champ de saisie
            CTkMessagebox(title="Succ√®s", message="Mati√®re ajout√©e", icon="check")  # Message de succ√®s
        except ValueError:
            CTkMessagebox(title="Erreur", message="Montant invalide", icon="cancel")  # Message d'erreur si le montant est invalide

    def create_subjects_treeview(self, parent):
        columns = ("Mati√®re", "Frais")
        treeview = ttk.Treeview(parent, columns=columns, show="headings")

        for col in columns:
            treeview.heading(col, text=col)

        treeview.pack(padx=20, pady=20, fill="both", expand=True)
        return treeview

    def update_subjects_treeview(self, level):
        cursor = self.conn.cursor()
        
        # R√©cup√©rer les mati√®res et frais selon le niveau
        cursor.execute("SELECT name, fee FROM Subjects WHERE level = ?", (level,))
        rows = cursor.fetchall()
        
        # Effacement des anciennes donn√©es
        treeview = self.college_subjects_treeview if level == "College" else self.high_school_subjects_treeview
        for i in treeview.get_children():
            treeview.delete(i)
        
        # Insertion des nouvelles donn√©es
        for row in rows:
            treeview.insert("", "end", values=(row[0], row[1]))

						
    def create_registration_tab(self, tab):
        # Titre principal
        ctk.CTkLabel(tab, text="Inscription des √âl√®ves", font=("Arial", 24, "bold")).pack(pady=10)
        
        # Frame principale divis√©e en deux parties
        main_frame = ctk.CTkFrame(tab)
        main_frame.pack(fill="both", expand=True, padx=20, pady=10)
        
        # Frame gauche pour le formulaire
        form_frame = ctk.CTkFrame(main_frame)
        form_frame.pack(side="left", fill="both", expand=True, padx=10, pady=10)
        
        # Frame droite pour la photo et les documents
        docs_frame = ctk.CTkFrame(main_frame)
        docs_frame.pack(side="right", fill="both", expand=True, padx=10, pady=10)
        
        # === FORMULAIRE D'INSCRIPTION ===
        self.create_registration_form(form_frame)
        
        # === SECTION PHOTO ET DOCUMENTS ===
        self.create_documents_section(docs_frame)
    
    def create_registration_form(self, parent):
        # Cr√©ation des variables pour stocker les donn√©es
        self.registration_vars = {
            "name": ctk.StringVar(),
            "surname": ctk.StringVar(),
            "birth_date": ctk.StringVar(),
            "gender": ctk.StringVar(value="M"),
            "address": ctk.StringVar(),
            "class": ctk.StringVar(),
            "phone": ctk.StringVar(),
            "parent_name": ctk.StringVar(),
            "parent_phone": ctk.StringVar(),
            "email": ctk.StringVar()
        }
        
        # Style des labels et entr√©es
        label_font = ("Arial", 12)
        entry_width = 250
        
        # Cr√©ation de deux colonnes pour le formulaire
        left_form = ctk.CTkFrame(parent)
        left_form.pack(side="left", fill="both", expand=True, padx=10)
        
        right_form = ctk.CTkFrame(parent)
        right_form.pack(side="right", fill="both", expand=True, padx=10)
        
        # === COLONNE GAUCHE ===
        # Informations personnelles
        ctk.CTkLabel(left_form, text="Informations Personnelles", 
                     font=("Arial", 14, "bold")).pack(pady=10)
        
        # Nom
        field_frame = ctk.CTkFrame(left_form)
        field_frame.pack(fill="x", pady=5)
        ctk.CTkLabel(field_frame, text="Nom*:", font=label_font).pack(side="left")
        name_entry = ctk.CTkEntry(field_frame, width=entry_width, 
                                 textvariable=self.registration_vars["name"])
        name_entry.pack(side="right")
        
        # Pr√©nom
        field_frame = ctk.CTkFrame(left_form)
        field_frame.pack(fill="x", pady=5)
        ctk.CTkLabel(field_frame, text="Pr√©nom*:", font=label_font).pack(side="left")
        surname_entry = ctk.CTkEntry(field_frame, width=entry_width, 
                                    textvariable=self.registration_vars["surname"])
        surname_entry.pack(side="right")
        
        # Date de naissance
        field_frame = ctk.CTkFrame(left_form)
        field_frame.pack(fill="x", pady=5)
        ctk.CTkLabel(field_frame, text="Date de naissance*:", 
                     font=label_font).pack(side="left")
        
        # Cr√©ation d'un s√©lecteur de date personnalis√©
        date_frame = ctk.CTkFrame(field_frame)
        date_frame.pack(side="right")
        
        self.day_var = ctk.StringVar(value="01")
        self.month_var = ctk.StringVar(value="01")
        self.year_var = ctk.StringVar(value="2000")
        
        # Jour
        day_menu = ctk.CTkOptionMenu(date_frame, 
                                    values=[f"{i:02d}" for i in range(1, 32)],
                                    variable=self.day_var,
                                    width=60)
        day_menu.pack(side="left", padx=2)
        
        # Mois
        month_menu = ctk.CTkOptionMenu(date_frame,
                                      values=[f"{i:02d}" for i in range(1, 13)],
                                      variable=self.month_var,
                                      width=60)
        month_menu.pack(side="left", padx=2)
        
        # Ann√©e
        current_year = datetime.now().year
        year_menu = ctk.CTkOptionMenu(date_frame,
                                     values=[str(i) for i in range(current_year-30, current_year+1)],
                                     variable=self.year_var,
                                     width=80)
        year_menu.pack(side="left", padx=2)
        
        # Genre
        field_frame = ctk.CTkFrame(left_form)
        field_frame.pack(fill="x", pady=5)
        ctk.CTkLabel(field_frame, text="Genre:", font=label_font).pack(side="left")
        gender_frame = ctk.CTkFrame(field_frame)
        gender_frame.pack(side="right")
        
        ctk.CTkRadioButton(gender_frame, text="Masculin", 
                          variable=self.registration_vars["gender"], 
                          value="M").pack(side="left", padx=10)
        ctk.CTkRadioButton(gender_frame, text="F√©minin", 
                          variable=self.registration_vars["gender"], 
                          value="F").pack(side="left", padx=10)
        
        # Adresse
        field_frame = ctk.CTkFrame(left_form)
        field_frame.pack(fill="x", pady=5)
        ctk.CTkLabel(field_frame, text="Adresse:", font=label_font).pack(side="left")
        address_entry = ctk.CTkEntry(field_frame, width=entry_width, 
                                    textvariable=self.registration_vars["address"])
        address_entry.pack(side="right")
        
        # === COLONNE DROITE ===
        # Informations scolaires
        ctk.CTkLabel(right_form, text="Informations Scolaires", 
                     font=("Arial", 14, "bold")).pack(pady=10)
        
        # Classe
        # Modification pour la s√©lection de classe
        field_frame = ctk.CTkFrame(right_form)
        field_frame.pack(fill="x", pady=5)
        ctk.CTkLabel(field_frame, text="Classe*:", font=label_font).pack(side="left")
		
		# Lier la variable class_level √† registration_vars["class"]
        self.registration_vars["class"] = ctk.StringVar(value="Primary")  # Valeur par d√©faut
        self.class_level = self.registration_vars["class"]  # Utiliser la m√™me variable
        
        # Liste fixe des niveaux
        levels = ["Primary", "College", "High School"]
        
        # Cr√©er le menu d√©roulant pour la classe
        self.class_level = ctk.StringVar()
        class_menu = ctk.CTkOptionMenu(
            field_frame,
            variable=self.class_level,
            values=levels,
            command=self.update_subjects_field,  # Ajouter cette fonction de callback
            width=entry_width
        )
        class_menu.pack(side="right")
        
        # Ajouter un frame pour les mati√®res
        self.subjects_frame = ctk.CTkFrame(right_form)
        self.subjects_frame.pack(fill="x", pady=5)
        self.subject_checkboxes = []  # Pour stocker les r√©f√©rences aux checkboxes
        
        # Cr√©er le label pour les mati√®res
        ctk.CTkLabel(self.subjects_frame, text="Mati√®res disponibles:", 
                     font=("Arial", 12, "bold")).pack(pady=5)
            
       
        
        # T√©l√©phone
        field_frame = ctk.CTkFrame(right_form)
        field_frame.pack(fill="x", pady=5)
        ctk.CTkLabel(field_frame, text="T√©l√©phone:", font=label_font).pack(side="left")
        phone_entry = ctk.CTkEntry(field_frame, width=entry_width, 
                                  textvariable=self.registration_vars["phone"])
        phone_entry.pack(side="right")
        
        # Email
        field_frame = ctk.CTkFrame(right_form)
        field_frame.pack(fill="x", pady=5)
        ctk.CTkLabel(field_frame, text="Email:", font=label_font).pack(side="left")
        email_entry = ctk.CTkEntry(field_frame, width=entry_width, 
                                  textvariable=self.registration_vars["email"])
        email_entry.pack(side="right")
        
        # Information du parent/tuteur
        ctk.CTkLabel(right_form, text="Information du Parent/Tuteur", 
                     font=("Arial", 14, "bold")).pack(pady=10)
        
        # Nom du parent
        field_frame = ctk.CTkFrame(right_form)
        field_frame.pack(fill="x", pady=5)
        ctk.CTkLabel(field_frame, text="Nom du parent*:", 
                     font=label_font).pack(side="left")
        parent_name_entry = ctk.CTkEntry(field_frame, width=entry_width, 
                                        textvariable=self.registration_vars["parent_name"])
        parent_name_entry.pack(side="right")
        
        # T√©l√©phone du parent
        field_frame = ctk.CTkFrame(right_form)
        field_frame.pack(fill="x", pady=5)
        ctk.CTkLabel(field_frame, text="T√©l√©phone parent*:", 
                     font=label_font).pack(side="left")
        parent_phone_entry = ctk.CTkEntry(field_frame, width=entry_width, 
                                         textvariable=self.registration_vars["parent_phone"])
        parent_phone_entry.pack(side="right")
        
        # Boutons d'action
        buttons_frame = ctk.CTkFrame(parent)
        buttons_frame.pack(fill="x", pady=20)
        
        ctk.CTkButton(buttons_frame, text="Enregistrer", 
                      command=self.save_student).pack(side="left", padx=10)
        ctk.CTkButton(buttons_frame, text="R√©initialiser", 
                      command=self.reset_form).pack(side="left", padx=10)
					  
		# Ajouter un frame pour le montant total apr√®s le subjects_frame
        self.total_amount_frame = ctk.CTkFrame(right_form)
        self.total_amount_frame.pack(fill="x", pady=10)
        
        ctk.CTkLabel(
            self.total_amount_frame, 
            text="Montant total √† payer:",
            font=("Arial", 14, "bold")
        ).pack(side="left", padx=10)
        
        self.total_amount_label = ctk.CTkLabel(
            self.total_amount_frame,
            text="0.00 ‚Ç¨",
            font=("Arial", 14, "bold"),
            text_color="#2E7D32"  # Vert pour le montant
        )
        self.total_amount_label.pack(side="right", padx=10)
        self.registration_vars["class"] = self.class_level  # Ajoutez cette ligne si ce n'est pas d√©j√† fait

        # Frame pour le statut du paiement
        self.payment_status_frame = ctk.CTkFrame(right_form)
        self.payment_status_frame.pack(fill="x", pady=10)
        
        # Variable pour le statut du paiement
        self.payment_completed = ctk.BooleanVar(value=False)
        
        # Checkbox pour le paiement
        self.payment_checkbox = ctk.CTkCheckBox(
            self.payment_status_frame,
            text="Paiement effectu√©",
            variable=self.payment_completed,
            command=self.update_payment_status,
            font=("Arial", 12, "bold"),
            text_color="#2E7D32"  # Vert
        )
        self.payment_checkbox.pack(side="left", padx=10, pady=5)
        
        # Label pour le statut
        self.payment_status_label = ctk.CTkLabel(
            self.payment_status_frame,
            text="Non pay√©",
            font=("Arial", 12, "bold"),
            text_color="#C62828"  # Rouge
        )
        self.payment_status_label.pack(side="right", padx=10)        
		
    def update_payment_status(self):
        """Met √† jour l'affichage du statut de paiement"""
        if self.payment_completed.get():
            self.payment_status_label.configure(
                text="Pay√©",
                text_color="#2E7D32"  # Vert pour pay√©
            )
            
            # Mettre √† jour le montant total pay√©
            total_fee = float(self.total_amount_label.cget("text").replace(" ‚Ç¨", ""))
            self.total_paid = total_fee
            
        else:
            self.payment_status_label.configure(
                text="Non pay√©",
                text_color="#C62828"  # Rouge pour non pay√©
            )
            self.total_paid = 0
            
        # Mettre √† jour l'affichage du montant total pay√© si n√©cessaire
        if hasattr(self, 'total_paid_label'):
            self.total_paid_label.configure(text=f"{self.total_paid:.2f} ‚Ç¨")
    def create_documents_section(self, parent):
        # Section Photo
        photo_frame = ctk.CTkFrame(parent)
        photo_frame.pack(fill="x", pady=10)
        
        ctk.CTkLabel(photo_frame, text="Photo de l'√©l√®ve", 
                     font=("Arial", 14, "bold")).pack(pady=5)
        
        # Zone pour la photo
        self.photo_frame = ctk.CTkFrame(photo_frame, width=200, height=200)
        self.photo_frame.pack(pady=5)
        self.photo_frame.pack_propagate(False)
        
        self.photo_label = ctk.CTkLabel(self.photo_frame, text="Aucune photo")
        self.photo_label.pack(expand=True)
        
        self.photo_path = None
        
        # Boutons pour la photo
        photo_buttons_frame = ctk.CTkFrame(photo_frame)
        photo_buttons_frame.pack(pady=5)
        
        ctk.CTkButton(photo_buttons_frame, text="Ajouter une photo", 
                      command=self.add_photo).pack(side="left", padx=5)
        ctk.CTkButton(photo_buttons_frame, text="Supprimer", 
                      command=self.remove_photo).pack(side="left", padx=5)
        
        # Section Documents
        docs_frame = ctk.CTkFrame(parent)
        docs_frame.pack(fill="both", expand=True, pady=10)
        
        ctk.CTkLabel(docs_frame, text="Documents requis", 
                     font=("Arial", 14, "bold")).pack(pady=5)
        
        # Liste des documents requis avec leur statut
        self.doc_vars = {}
        self.doc_paths = {}
        required_docs = [
            ("Copie CIN parent", True),
            ("Certificat de naissance", True),
            ("Photo d'identit√©", True),
            ("Carnet de vaccination", True),
            ("Dernier bulletin scolaire", True),
            ("Attestation de travail parent", False),
            ("Autres documents", False)
        ]
        
        for doc, required in required_docs:
            frame = ctk.CTkFrame(docs_frame)
            frame.pack(fill="x", pady=2, padx=5)
            
            # Variable pour le statut du document
            status_var = ctk.BooleanVar()
            self.doc_vars[doc] = status_var
            self.doc_paths[doc] = None
            
            # Checkbox et label
            chk = ctk.CTkCheckBox(frame, text=doc, variable=status_var)
            chk.pack(side="left", padx=5)
            
            if required:
                req_label = ctk.CTkLabel(frame, text="*", text_color="red")
                req_label.pack(side="left")
            
            # Boutons pour le document
            btn_frame = ctk.CTkFrame(frame)
            btn_frame.pack(side="right")
            
            ctk.CTkButton(btn_frame, text="Ajouter", 
                         command=lambda d=doc: self.add_document(d)).pack(side="left", padx=2)
            ctk.CTkButton(btn_frame, text="Voir", 
                         command=lambda d=doc: self.view_document(d)).pack(side="left", padx=2)
    
    def add_photo(self):
        file_path = filedialog.askopenfilename(
            title="S√©lectionner une photo",
            filetypes=[("Images", "*.png *.jpg *.jpeg *.gif *.bmp")]
        )
        
        if file_path:
            try:
                # Ouvrir et redimensionner l'image
                image = Image.open(file_path)
                image = image.resize((180, 180), Image.Resampling.LANCZOS)
                
                # Convertir en format compatible avec CTkinter
                photo = ImageTk.PhotoImage(image)
                
                # Mettre √† jour le label
                self.photo_label.configure(image=photo, text="")
                self.photo_label.image = photo  # Garder une r√©f√©rence
                
                # Sauvegarder le chemin
                self.photo_path = file_path
                
            except Exception as e:
                CTkMessagebox(title="Erreur", 
                             message=f"Erreur lors du chargement de l'image: {str(e)}", 
                             icon="cancel")
    
    def remove_photo(self):
        self.photo_label.configure(image=None, text="Aucune photo")
        self.photo_path = None
    
    def add_document(self, doc_name):
        file_path = filedialog.askopenfilename(
            title=f"S√©lectionner le document - {doc_name}",
            filetypes=[
                ("Documents", "*.pdf *.doc *.docx *.jpg *.jpeg *.png"),
                ("PDF", "*.pdf"),
                ("Word", "*.doc *.docx"),
                ("Images", "*.jpg *.jpeg *.png")
            ]
        )
        
        if file_path:
            self.doc_paths[doc_name] = file_path
            self.doc_vars[doc_name].set(True)
            
            # Afficher une confirmation
            CTkMessagebox(title="Succ√®s", 
                         message=f"Document '{doc_name}' ajout√© avec succ√®s", 
                         icon="check")
    
    def view_document(self, doc_name):
        if self.doc_paths.get(doc_name):
            try:
                os.startfile(self.doc_paths[doc_name])
            except Exception as e:
                CTkMessagebox(title="Erreur", 
                             message=f"Erreur lors de l'ouverture du document: {str(e)}", 
                             icon="cancel")
        else:
            CTkMessagebox(title="Information", 
                         message="Aucun document n'a √©t√© ajout√©", 
                         icon="info")
    
    def save_student(self):
        # Validation des champs requis
        required_fields = {
            "name": "Nom",
            "surname": "Pr√©nom",
            "class": "Classe",
            "parent_name": "Nom du parent",
            "parent_phone": "T√©l√©phone parent"
        }
        
        # V√©rification des champs obligatoires
        for field, label in required_fields.items():
            if not self.registration_vars[field].get().strip():
                CTkMessagebox(
                    title="Erreur", 
                    message=f"Le champ '{label}' est obligatoire", 
                    icon="cancel"
                )
                return
    
        try:
            # R√©cup√©rer les mati√®res s√©lectionn√©es et calculer le total
            selected_subjects = []
            selected_level = self.registration_vars["class"].get()
            
            # R√©cup√©rer les mati√®res s√©lectionn√©es
            for subject_name, var, fee in self.subject_checkboxes:
                if var.get():
                    selected_subjects.append(subject_name)
            
            # Convertir la liste des mati√®res en cha√Æne
            subjects_str = ", ".join(selected_subjects)
        
            # Construire la date de naissance
            birth_date = f"{self.year_var.get()}-{self.month_var.get()}-{self.day_var.get()}"
            
            # R√©cup√©rer le montant total depuis le label
            total_fee = float(self.total_amount_label.cget("text").replace(" ‚Ç¨", ""))
            
            # Statut du paiement et montant pay√©
            payment_completed = self.payment_completed.get()
            total_paid = total_fee if payment_completed else 0
            
            # Cr√©er un curseur
            cursor = self.conn.cursor()
            
            # Ins√©rer l'√©tudiant dans la base de donn√©es
            cursor.execute("""
                INSERT INTO Students (
                    name, 
                    surname, 
                    birth_date, 
                    gender, 
                    address, 
                    class,
                    phone_number, 
                    parent_name, 
                    parent_phone, 
                    email,
                    registration_date, 
                    photo_path, 
                    subjects, 
                    total_fee,
                    total_paid, 
                    payment_completed, 
                    last_payment_date
                ) VALUES (
                    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 
                    CURRENT_TIMESTAMP, ?, ?, ?, ?, ?, 
                    CASE WHEN ? = 1 THEN CURRENT_TIMESTAMP ELSE NULL END
                )
            """, (
                self.registration_vars["name"].get(),
                self.registration_vars["surname"].get(),
                birth_date,
                self.registration_vars["gender"].get(),
                self.registration_vars["address"].get(),
                selected_level,
                self.registration_vars["phone"].get(),
                self.registration_vars["parent_name"].get(),
                self.registration_vars["parent_phone"].get(),
                self.registration_vars["email"].get(),
                self.photo_path,
                subjects_str,
                total_fee,
                total_paid,
                payment_completed,
                payment_completed
            ))
            
            # R√©cup√©rer l'ID de l'√©tudiant nouvellement ins√©r√©
            student_id = cursor.lastrowid
            
            # Si le paiement est effectu√©, cr√©er une entr√©e dans la table Payments
            if payment_completed:
                cursor.execute("""
                    INSERT INTO Payments (
                        student_id, 
                        amount, 
                        payment_date, 
                        payment_method, 
                        notes
                    ) VALUES (?, ?, CURRENT_TIMESTAMP, ?, ?)
                """, (
                    student_id,
                    total_fee,
                    "Paiement initial",
                    "Paiement effectu√© lors de l'inscription"
                ))
            
            # Sauvegarder les documents
            for doc_name, path in self.doc_paths.items():
                if path:
                    cursor.execute("""
                        INSERT INTO StudentDocuments (
                            student_id, 
                            document_type, 
                            file_path, 
                            uploaded_date
                        ) VALUES (?, ?, ?, CURRENT_TIMESTAMP)
                    """, (student_id, doc_name, path))
            
            # Valider les changements dans la base de donn√©es
            self.conn.commit()
            
            # Afficher message de succ√®s
            CTkMessagebox(
                title="Succ√®s", 
                message="√âl√®ve enregistr√© avec succ√®s!", 
                icon="check"
            )
            
            # R√©initialiser le formulaire
            self.reset_form()
            
        except sqlite3.Error as e:
            # En cas d'erreur SQL, annuler les changements
            if hasattr(self, 'conn'):
                self.conn.rollback()
            CTkMessagebox(
                title="Erreur", 
                message=f"Erreur lors de l'enregistrement dans la base de donn√©es: {str(e)}", 
                icon="cancel"
            )
        except Exception as e:
            # Capture les autres erreurs possibles
            CTkMessagebox(
                title="Erreur", 
                message=f"Une erreur inattendue s'est produite: {str(e)}", 
                icon="cancel"
            )
    def reset_form(self):
        # R√©initialiser les champs du formulaire
        for var in self.registration_vars.values():
            var.set("")
        
        # R√©initialiser la date
        self.day_var.set("01")
        self.month_var.set("01")
        self.year_var.set("2000")
        
        # R√©initialiser la photo
        self.remove_photo()
        
        # R√©initialiser les documents
        self.doc_paths.clear()
        for var in self.doc_vars.values():
            var.set(False)
		
        # R√©initialiser le statut du paiement
        self.payment_completed.set(False)
        self.update_payment_status()
    def update_subjects_field(self, *args):
        # Effacer les anciennes checkboxes
        for widget in self.subjects_frame.winfo_children():
            widget.destroy()
    
        # R√©cup√©rer le niveau s√©lectionn√© du menu d√©roulant
        selected_level = self.class_level.get()
        print(f"Niveau s√©lectionn√©: {selected_level}")  # Debug
    
        try:
            cursor = self.conn.cursor()
            
            if selected_level == "Primary":
                # Pour le niveau primaire, r√©cup√©rer le montant fixe
                cursor.execute("SELECT amount FROM FeeConfiguration WHERE level = 'Primary'")
                result = cursor.fetchone()
                if result:
                    primary_fee = result[0]
                    # Cr√©er une seule checkbox pour le montant fixe
                    var = ctk.BooleanVar(value=True)
                    checkbox = ctk.CTkCheckBox(
                        self.subjects_frame, 
                        text=f"Toutes les mati√®res - Montant fixe: {primary_fee:.2f} ‚Ç¨",
                        variable=var,
                        state="disabled"  # D√©sactiv√© car c'est un montant fixe
                    )
                    checkbox.pack(pady=10)
                    self.subject_checkboxes = [("Primary_All", var, primary_fee)]
                    # Mettre √† jour le montant total
                    self.total_amount_label.configure(text=f"{primary_fee:.2f} ‚Ç¨")
                else:
                    ctk.CTkLabel(
                        self.subjects_frame,
                        text="Aucun montant configur√© pour le niveau primaire",
                        text_color="red"
                    ).pack(pady=10)
            else:
                # Pour College et High School
                cursor.execute("""
                    SELECT name, fee FROM Subjects 
                    WHERE level = ?
                    ORDER BY name
                """, (selected_level,))
                
                subjects = cursor.fetchall()
                self.subject_checkboxes = []
                
                if subjects:
                    # Cr√©er un frame pour contenir toutes les mati√®res
                    subjects_container = ctk.CTkFrame(self.subjects_frame)
                    subjects_container.pack(fill="both", expand=True, padx=5, pady=5)
                    
                    # Label d'en-t√™te
                    header_frame = ctk.CTkFrame(subjects_container)
                    header_frame.pack(fill="x", pady=(0, 5))
                    ctk.CTkLabel(header_frame, text="Mati√®res disponibles:", 
                                font=("Arial", 12, "bold")).pack(pady=5)
                    
                    # Cr√©er les checkboxes pour chaque mati√®re
                    for subject_name, fee in subjects:
                        var = ctk.BooleanVar()
                        frame = ctk.CTkFrame(subjects_container)
                        frame.pack(fill="x", pady=2)
                        
                        checkbox = ctk.CTkCheckBox(
                            frame,
                            text=f"{subject_name}",
                            variable=var,
                            command=self.calculate_total
                        )
                        checkbox.pack(side="left", padx=5)
                        
                        # Afficher le montant √† droite
                        fee_label = ctk.CTkLabel(
                            frame,
                            text=f"{fee:.2f} ‚Ç¨",
                            font=("Arial", 12)
                        )
                        fee_label.pack(side="right", padx=5)
                        
                        self.subject_checkboxes.append((subject_name, var, fee))
                    
                    # Ajouter un bouton "Tout s√©lectionner"
                    select_all_var = ctk.BooleanVar()
                    select_all_btn = ctk.CTkCheckBox(
                        subjects_container,
                        text="Tout s√©lectionner",
                        variable=select_all_var,
                        command=lambda: self.toggle_all_subjects(select_all_var.get())
                    )
                    select_all_btn.pack(pady=10)
                    
                    # Initialiser le montant total √† 0
                    self.calculate_total()
                else:
                    ctk.CTkLabel(
                        self.subjects_frame,
                        text=f"Aucune mati√®re configur√©e pour le niveau {selected_level}",
                        text_color="red"
                    ).pack(pady=10)
                    print(f"Aucune mati√®re trouv√©e pour le niveau {selected_level}")
                    
        except sqlite3.Error as e:
            print(f"Erreur SQL: {e}")
            CTkMessagebox(
                title="Erreur",
                message=f"Erreur lors de la r√©cup√©ration des mati√®res: {str(e)}",
                icon="cancel"
            )
    
    def toggle_all_subjects(self, state):
        """S√©lectionner ou d√©s√©lectionner toutes les mati√®res"""
        for _, var, _ in self.subject_checkboxes:
            var.set(state)
        self.calculate_total()
    
    def calculate_total(self, *args):
        """Calculer le montant total en fonction des mati√®res s√©lectionn√©es"""
        total = 0
        selected_level = self.class_level.get()
        
        try:
            if selected_level == "Primary":
                # Pour le primaire, utiliser le montant fixe
                if self.subject_checkboxes:
                    total = self.subject_checkboxes[0][2]
            else:
                # Pour les autres niveaux, calculer la somme des mati√®res s√©lectionn√©es
                for _, var, fee in self.subject_checkboxes:
                    if var.get():
                        total += fee
    
            # Mettre √† jour le label avec le nouveau total
            self.total_amount_label.configure(text=f"{total:.2f} ‚Ç¨")
            
            # Changer la couleur en fonction du montant
            if total > 0:
                self.total_amount_label.configure(text_color="#2E7D32")  # Vert
            else:
                self.total_amount_label.configure(text_color="#C62828")  # Rouge
                
        except Exception as e:
            CTkMessagebox(
                title="Erreur",
                message=f"Erreur lors du calcul du total: {str(e)}",
                icon="cancel"
            )
    def update_subject_checkboxes(self):
        # Efface les anciennes checkboxes avant de mettre √† jour
        for widget in self.subjects_frame.winfo_children():
            widget.destroy()
        
        level = self.class_level.get()
        if level not in ["Primary"]:
            # R√©cup√©rer les mati√®res pour le niveau s√©lectionn√©
            cursor = self.conn.cursor()
            cursor.execute("SELECT name FROM Subjects WHERE level = ?", (level,))
            rows = cursor.fetchall()
        
            # Cr√©er une case √† cocher pour chaque mati√®re
            self.subject_checkboxes = []
            for row in rows:
                subject_name = row[0]
                var = ctk.BooleanVar()
                checkbox = ctk.CTkCheckBox(self.subjects_frame, text=subject_name, variable=var)
                checkbox.pack(pady=2, anchor='w')
                self.subject_checkboxes.append((checkbox, var))  # Enregistrer la checkbox et la variable
			

    def register_student(self):
        try:
            cursor = self.conn.cursor()

            # R√©cup√©rer les mati√®res s√©lectionn√©es
            selected_subjects = [name for name, var in self.subject_checkboxes if var.get()]
            subjects_str = ", ".join(selected_subjects) if selected_subjects else "Aucune"

            # Insertion dans la base de donn√©es
            cursor.execute("""
                INSERT INTO Students 
                (name, surname, class, phone_number, payment_completed, subjects) 
                VALUES (?, ?, ?, ?, ?, ?)
            """, (
                self.name_entry.get(),
                self.surname_entry.get(),
                self.class_level.get(),
                self.phone_entry.get(),
                self.payment_completed.get(),
                subjects_str
            ))
            self.conn.commit()
            CTkMessagebox(title="Succ√®s", message="√âl√®ve inscrit avec succ√®s !", icon="check")
        except Exception as e:
            CTkMessagebox(title="Erreur", message=f"Erreur d'inscription : {str(e)}", icon="cancel")
			
    def create_payment_tracking_tab(self, tab):
        # Suivi des paiements
        ctk.CTkLabel(tab, text="Suivi des Paiements", font=("Arial", 20, "bold")).pack(pady=10)
        
        # Frame principale divis√©e en deux parties
        main_frame = ctk.CTkFrame(tab)
        main_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        # Frame gauche pour la recherche et le tableau
        left_frame = ctk.CTkFrame(main_frame)
        left_frame.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        
        # Frame droite pour les d√©tails et actions
        right_frame = ctk.CTkFrame(main_frame)
        right_frame.pack(side="right", fill="both", padx=5, pady=5, expand=True)
        
        # === PARTIE GAUCHE ===
        # Frame de recherche
        search_frame = ctk.CTkFrame(left_frame)
        search_frame.pack(fill="x", padx=5, pady=5)
        
        # Barre de recherche avec ic√¥ne
        ctk.CTkLabel(search_frame, text="üîç", font=("Arial", 16)).pack(side="left", padx=5)
        self.search_entry = ctk.CTkEntry(search_frame, width=200, placeholder_text="Rechercher un √©l√®ve...")
        self.search_entry.pack(side="left", padx=5, pady=5)
        
        # Filtre par statut
        self.status_var = ctk.StringVar(value="Tous")
        status_filter = ctk.CTkOptionMenu(
            search_frame,
            values=["Tous", "Pay√©", "Non pay√©", "Partiel"],
            variable=self.status_var,
            command=self.filter_payments
        )
        status_filter.pack(side="left", padx=5)
        
        # Filtre par classe
        self.class_filter_var = ctk.StringVar(value="Toutes")
        class_filter = ctk.CTkOptionMenu(
            search_frame,
            values=["Toutes", "Primary", "College", "High School"],
            variable=self.class_filter_var,
            command=self.filter_payments
        )
        class_filter.pack(side="left", padx=5)
        
        # Tableau des paiements
        columns = ("ID", "Nom", "Pr√©nom", "Classe", "Total Pay√©", "Statut", "Dernier Paiement")
        self.payment_treeview = ttk.Treeview(left_frame, columns=columns, show="headings", height=20)
        
        # Configuration des colonnes
        column_widths = {
            "ID": 50, "Nom": 120, "Pr√©nom": 120, "Classe": 100,
            "Total Pay√©": 100, "Statut": 100, "Dernier Paiement": 150
        }
        
        for col, width in column_widths.items():
            self.payment_treeview.heading(col, text=col, command=lambda c=col: self.sort_treeview(c))
            self.payment_treeview.column(col, width=width, anchor="center")
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(left_frame, orient="vertical", command=self.payment_treeview.yview)
        self.payment_treeview.configure(yscrollcommand=scrollbar.set)
        
        self.payment_treeview.pack(side="left", fill="both", expand=True, pady=5)
        scrollbar.pack(side="right", fill="y")
        
        # Binding pour la s√©lection
        self.payment_treeview.bind("<<TreeviewSelect>>", self.show_student_details)
        
        # === PARTIE DROITE ===
        # D√©tails de l'√©l√®ve
        ctk.CTkLabel(right_frame, text="D√©tails de l'√âl√®ve", font=("Arial", 16, "bold")).pack(pady=10)
        
        # Frame pour les d√©tails
        self.details_frame = ctk.CTkFrame(right_frame)
        self.details_frame.pack(fill="x", padx=5, pady=5)
        
        # Labels pour les d√©tails
        self.detail_labels = {}
        for field in ["Nom complet", "Classe", "T√©l√©phone", "Date d'inscription", "Montant total", "Statut"]:
            frame = ctk.CTkFrame(self.details_frame)
            frame.pack(fill="x", pady=2)
            ctk.CTkLabel(frame, text=f"{field}:", font=("Arial", 12, "bold")).pack(side="left", padx=5)
            self.detail_labels[field] = ctk.CTkLabel(frame, text="", font=("Arial", 12))
            self.detail_labels[field].pack(side="left", padx=5)
        
        # Frame pour les actions
        actions_frame = ctk.CTkFrame(right_frame)
        actions_frame.pack(fill="x", pady=10)
        
        # Champ pour le nouveau paiement
        payment_frame = ctk.CTkFrame(actions_frame)
        payment_frame.pack(fill="x", pady=5)
        
        ctk.CTkLabel(payment_frame, text="Montant:").pack(side="left", padx=5)
        self.payment_amount = ctk.CTkEntry(payment_frame, width=100)
        self.payment_amount.pack(side="left", padx=5)
        
        # Boutons d'action
        buttons_frame = ctk.CTkFrame(actions_frame)
        buttons_frame.pack(fill="x", pady=5)
        
        ctk.CTkButton(
            buttons_frame,
            text="Enregistrer Paiement",
            command=self.register_payment
        ).pack(side="left", padx=5)
        
        ctk.CTkButton(
            buttons_frame,
            text="Historique",
            command=self.show_payment_history
        ).pack(side="left", padx=5)
        
        ctk.CTkButton(
            buttons_frame,
            text="Imprimer Re√ßu",
            command=self.print_receipt
        ).pack(side="left", padx=5)
        
        # Initialiser l'affichage
        self.update_payment_treeview()

    def get_student_names(self):
        cursor = self.conn.cursor()
        cursor.execute("SELECT name || ' ' || surname FROM Students")
        return [name[0] for name in cursor.fetchall()]

    def record_student_payment(self):
        try:
            student_name = self.student_payment_combo.get()
            payment_amount = float(self.payment_amount_entry.get())

            cursor = self.conn.cursor()
            cursor.execute("SELECT id FROM Students WHERE name || ' ' || surname = ?", (student_name,))
            student_id = cursor.fetchone()[0]

            cursor.execute("""
                INSERT INTO Payments (student_id, amount, date) 
                VALUES (?, ?, ?)
            """, (student_id, payment_amount, datetime.now().strftime('%Y-%m-%d')))

            self.conn.commit()

            CTkMessagebox(
                title="Succ√®s",
                message="Paiement enregistr√© !",
                icon="check"
            )

            # Mise √† jour du treeview
            self.update_payment_treeview()
        except Exception as e:
            CTkMessagebox(
                title="Erreur",
                message=f"Erreur d'enregistrement : {str(e)}",
                icon="cancel"
            )

    def create_payment_treeview(self, parent):
        # Cr√©ation d'un treeview pour afficher les paiements
        columns = ("√âl√®ve", "Montant", "Date")
        treeview = ttk.Treeview(parent, columns=columns, show="headings")

        for col in columns:
            treeview.heading(col, text=col)

        treeview.pack(padx=20, pady=20, fill="both", expand=True)
        return treeview
    def filter_payments(self, *args):
        self.update_payment_treeview()
		
    def update_payment_treeview(self):
        # Effacer les donn√©es existantes
        for item in self.payment_treeview.get_children():
            self.payment_treeview.delete(item)
        
        # Construire la requ√™te SQL
        query = """
            SELECT 
                id,
                name,
                surname,
                class,
                total_paid,
                CASE 
                    WHEN payment_completed = 1 THEN 'Pay√©'
                    WHEN total_paid > 0 THEN 'Partiel'
                    ELSE 'Non pay√©'
                END as status,
                last_payment_date
            FROM Students
            WHERE 1=1
        """
        
        params = []
        
        # Ajouter les filtres
        if self.search_entry.get():
            query += " AND (name LIKE ? OR surname LIKE ? OR phone_number LIKE ?)"
            search_term = f"%{self.search_entry.get()}%"
            params.extend([search_term, search_term, search_term])
        
        if self.status_var.get() != "Tous":
            query += " AND status = ?"
            params.append(self.status_var.get())
        
        if self.class_filter_var.get() != "Toutes":
            query += " AND class = ?"
            params.append(self.class_filter_var.get())
        
        try:
            cursor = self.conn.cursor()
            cursor.execute(query, params)
            
            # Ins√©rer les donn√©es dans le treeview
            for row in cursor.fetchall():
                # Formater le montant avec le symbole ‚Ç¨
                formatted_amount = f"{float(row[4]):.2f} ‚Ç¨" if row[4] else "0.00 ‚Ç¨"
                
                # Formater la date
                formatted_date = row[6] if row[6] else "Aucun paiement"
                
                values = (
                    row[0],  # ID
                    row[1],  # Nom
                    row[2],  # Pr√©nom
                    row[3],  # Classe
                    formatted_amount,  # Total pay√©
                    row[5],  # Statut
                    formatted_date  # Dernier paiement
                )
                
                # D√©finir la couleur selon le statut
                tag = row[5].lower()
                self.payment_treeview.insert("", "end", values=values, tags=(tag,))
            
            # Configurer les couleurs des tags
            self.payment_treeview.tag_configure("pay√©", background="#c8e6c9")
            self.payment_treeview.tag_configure("partiel", background="#fff9c4")
            self.payment_treeview.tag_configure("non pay√©", background="#ffcdd2")
            
        except sqlite3.Error as e:
            CTkMessagebox(title="Erreur", message=f"Erreur lors de la mise √† jour: {str(e)}", icon="cancel")
    
    def show_student_details(self, event):
        selected_item = self.payment_treeview.selection()
        if not selected_item:
            return
        
        # R√©cup√©rer l'ID de l'√©l√®ve
        student_id = self.payment_treeview.item(selected_item[0])['values'][0]
        
        try:
            cursor = self.conn.cursor()
            cursor.execute("""
                SELECT 
                    name || ' ' || surname as full_name,
                    class,
                    phone_number,
                    registration_date,
                    total_paid,
                    CASE 
                        WHEN payment_completed = 1 THEN 'Pay√©'
                        WHEN total_paid > 0 THEN 'Partiel'
                        ELSE 'Non pay√©'
                    END as status
                FROM Students
                WHERE id = ?
            """, (student_id,))
            
            student = cursor.fetchone()
            if student:
                # Mettre √† jour les labels
                self.detail_labels["Nom complet"].configure(text=student[0])
                self.detail_labels["Classe"].configure(text=student[1])
                self.detail_labels["T√©l√©phone"].configure(text=student[2] or "Non renseign√©")
                self.detail_labels["Date d'inscription"].configure(text=student[3])
                self.detail_labels["Montant total"].configure(text=f"{float(student[4]):.2f} ‚Ç¨")
                self.detail_labels["Statut"].configure(text=student[5])
                
        except sqlite3.Error as e:
            CTkMessagebox(title="Erreur", message=f"Erreur lors de la r√©cup√©ration des d√©tails: {str(e)}", icon="cancel")
    
    def register_payment(self):
        selected_item = self.payment_treeview.selection()
        if not selected_item:
            CTkMessagebox(title="Erreur", message="Veuillez s√©lectionner un √©l√®ve", icon="cancel")
            return
        
        try:
            amount = float(self.payment_amount.get())
            if amount <= 0:
                CTkMessagebox(title="Erreur", message="Le montant doit √™tre sup√©rieur √† 0", icon="cancel")
                return
            
            # R√©cup√©rer l'ID de l'√©l√®ve
            student_id = self.payment_treeview.item(selected_item[0])['values'][0]
            
            # Ouvrir une fen√™tre de confirmation de paiement
            self.show_payment_confirmation_dialog(student_id, amount)
            
        except ValueError:
            CTkMessagebox(title="Erreur", message="Veuillez entrer un montant valide", icon="cancel")
    
    def show_payment_confirmation_dialog(self, student_id, amount):
        # Cr√©er une nouvelle fen√™tre de dialogue
        dialog = ctk.CTkToplevel(self.root)
        dialog.title("Confirmation de Paiement")
        dialog.geometry("500x600")
        dialog.transient(self.root)  # Rendre la fen√™tre modale
        
        # R√©cup√©rer les informations de l'√©l√®ve
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT name, surname, class, total_paid
            FROM Students
            WHERE id = ?
        """, (student_id,))
        student = cursor.fetchone()
        
        # Afficher les d√©tails du paiement
        ctk.CTkLabel(dialog, text="D√©tails du Paiement", font=("Arial", 16, "bold")).pack(pady=10)
        
        details_frame = ctk.CTkFrame(dialog)
        details_frame.pack(fill="x", padx=20, pady=10)
        
        details = [
            ("√âl√®ve", f"{student[0]} {student[1]}"),
            ("Classe", student[2]),
            ("Montant actuel", f"{student[3]:.2f} ‚Ç¨"),
            ("Nouveau paiement", f"{amount:.2f} ‚Ç¨"),
            ("Total apr√®s paiement", f"{(student[3] + amount):.2f} ‚Ç¨")
        ]
        
        for label, value in details:
            row = ctk.CTkFrame(details_frame)
            row.pack(fill="x", pady=2)
            ctk.CTkLabel(row, text=label + ":", font=("Arial", 12, "bold")).pack(side="left", padx=5)
            ctk.CTkLabel(row, text=value).pack(side="left", padx=5)
        
        # M√©thode de paiement
        ctk.CTkLabel(dialog, text="M√©thode de paiement:", font=("Arial", 12)).pack(pady=5)
        payment_method = ctk.StringVar(value="Esp√®ces")
        methods = ["Esp√®ces", "Carte bancaire", "Ch√®que", "Virement"]
        for method in methods:
            ctk.CTkRadioButton(dialog, text=method, variable=payment_method, value=method).pack(pady=2)
        
        # Notes
        ctk.CTkLabel(dialog, text="Notes:", font=("Arial", 12)).pack(pady=5)
        notes_text = ctk.CTkTextbox(dialog, height=100)
        notes_text.pack(padx=20, pady=5, fill="x")
        
        # Boutons
        buttons_frame = ctk.CTkFrame(dialog)
        buttons_frame.pack(fill="x", padx=20, pady=20)
        
        def confirm_payment():
            self.process_payment(student_id, amount, payment_method.get(), notes_text.get("1.0", "end-1c"))
            dialog.destroy()
        
        def cancel():
            dialog.destroy()
        
        ctk.CTkButton(
            buttons_frame,
            text="Confirmer",
            command=confirm_payment,
            fg_color="green"
        ).pack(side="left", padx=5, expand=True)
        
        ctk.CTkButton(
            buttons_frame,
            text="Annuler",
            command=cancel,
            fg_color="red"
        ).pack(side="left", padx=5, expand=True)
    
    def process_payment(self, student_id, amount, payment_method, notes):
        try:
            cursor = self.conn.cursor()
            
            # Ins√©rer le paiement dans la table Payments
            cursor.execute("""
                INSERT INTO Payments (
                    student_id, amount, payment_date, payment_method, notes
                ) VALUES (?, ?, CURRENT_TIMESTAMP, ?, ?)
            """, (student_id, amount, payment_method, notes))
            
            # Mettre √† jour le total pay√© et la date du dernier paiement
            cursor.execute("""
                UPDATE Students 
                SET total_paid = total_paid + ?,
                    last_payment_date = CURRENT_TIMESTAMP,
                    payment_completed = CASE 
                        WHEN (total_paid + ?) >= 
                            (SELECT amount FROM FeeConfiguration WHERE level = Students.class)
                        THEN 1 ELSE 0 END
                WHERE id = ?
            """, (amount, amount, student_id))
            
            self.conn.commit()
            
            # Mettre √† jour l'affichage
            self.update_payment_treeview()
            
            # Proposer d'imprimer le re√ßu
            if CTkMessagebox(
                title="Succ√®s",
                message="Paiement enregistr√© avec succ√®s!\nVoulez-vous imprimer le re√ßu?",
                icon="check",
                option_1="Oui",
                option_2="Non"
            ).get() == "Oui":
                self.print_receipt(student_id, amount, payment_method, notes)
                
        except sqlite3.Error as e:
            CTkMessagebox(title="Erreur", 
                         message=f"Erreur lors de l'enregistrement du paiement: {str(e)}", 
                         icon="cancel")
						 
    def show_payment_history(self):
        selected_item = self.payment_treeview.selection()
        if not selected_item:
            CTkMessagebox(title="Erreur", message="Veuillez s√©lectionner un √©l√®ve", icon="cancel")
            return
        
        student_id = self.payment_treeview.item(selected_item[0])['values'][0]
        
        # Cr√©er une nouvelle fen√™tre pour l'historique
        history_window = ctk.CTkToplevel(self.root)
        history_window.title("Historique des Paiements")
        history_window.geometry("800x600")
        
        # R√©cup√©rer les informations de l'√©l√®ve
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT name, surname, class, total_paid
            FROM Students
            WHERE id = ?
        """, (student_id,))
        student = cursor.fetchone()
        
        # Frame d'en-t√™te avec les informations de l'√©l√®ve
        header_frame = ctk.CTkFrame(history_window)
        header_frame.pack(fill="x", padx=10, pady=5)
        
        student_info = ctk.CTkLabel(
            header_frame,
            text=f"√âl√®ve: {student[0]} {student[1]} | Classe: {student[2]} | Total pay√©: {student[3]:.2f} ‚Ç¨",
            font=("Arial", 14, "bold")
        )
        student_info.pack(pady=10)
        
        # Frame pour les filtres
        filter_frame = ctk.CTkFrame(history_window)
        filter_frame.pack(fill="x", padx=10, pady=5)
        
        # Filtre par date
        date_frame = ctk.CTkFrame(filter_frame)
        date_frame.pack(side="left", padx=5)
        
        ctk.CTkLabel(date_frame, text="P√©riode:").pack(side="left", padx=5)
        period_var = ctk.StringVar(value="Tout")
        period_menu = ctk.CTkOptionMenu(
            date_frame,
            values=["Tout", "Aujourd'hui", "Cette semaine", "Ce mois", "Cette ann√©e"],
            variable=period_var,
            command=lambda x: self.filter_history(history_tree, student_id, x)
        )
        period_menu.pack(side="left", padx=5)
        
        # Boutons d'export
        export_frame = ctk.CTkFrame(filter_frame)
        export_frame.pack(side="right", padx=5)
        
        ctk.CTkButton(
            export_frame,
            text="Exporter PDF",
            command=lambda: self.export_history_pdf(student_id)
        ).pack(side="left", padx=5)
        
        ctk.CTkButton(
            export_frame,
            text="Exporter Excel",
            command=lambda: self.export_history_excel(student_id)
        ).pack(side="left", padx=5)
        
        # Cr√©er le tableau d'historique
        columns = ("Date", "Montant", "M√©thode", "Notes", "Re√ßu")
        history_tree = ttk.Treeview(history_window, columns=columns, show="headings", height=20)
        
        # Configurer les colonnes
        column_widths = {
            "Date": 150,
            "Montant": 100,
            "M√©thode": 120,
            "Notes": 300,
            "Re√ßu": 100
        }
        
        for col, width in column_widths.items():
            history_tree.heading(col, text=col)
            history_tree.column(col, width=width)
        
        # Ajouter une scrollbar
        scrollbar = ttk.Scrollbar(history_window, orient="vertical", command=history_tree.yview)
        history_tree.configure(yscrollcommand=scrollbar.set)
        
        # Frame pour contenir le treeview et la scrollbar
        tree_frame = ctk.CTkFrame(history_window)
        tree_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        history_tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Charger l'historique
        self.load_payment_history(history_tree, student_id)
        
        # Ajouter un menu contextuel
        self.create_history_context_menu(history_tree, student_id)
    
    def load_payment_history(self, tree, student_id, period="Tout"):
        # Effacer les donn√©es existantes
        for item in tree.get_children():
            tree.delete(item)
        
        # Pr√©parer la requ√™te SQL en fonction de la p√©riode
        query = """
            SELECT 
                payment_date,
                amount,
                payment_method,
                notes,
                id
            FROM Payments
            WHERE student_id = ?
        """
        
        params = [student_id]
        
        if period != "Tout":
            current_date = datetime.now()
            if period == "Aujourd'hui":
                query += " AND date(payment_date) = date('now')"
            elif period == "Cette semaine":
                query += " AND date(payment_date) >= date('now', '-7 days')"
            elif period == "Ce mois":
                query += " AND strftime('%Y-%m', payment_date) = strftime('%Y-%m', 'now')"
            elif period == "Cette ann√©e":
                query += " AND strftime('%Y', payment_date) = strftime('%Y', 'now')"
        
        query += " ORDER BY payment_date DESC"
        
        try:
            cursor = self.conn.cursor()
            cursor.execute(query, params)
            
            for payment in cursor.fetchall():
                # Formater la date
                date_obj = datetime.strptime(payment[0], "%Y-%m-%d %H:%M:%S")
                formatted_date = date_obj.strftime("%d/%m/%Y %H:%M")
                
                # Formater le montant
                formatted_amount = f"{payment[1]:.2f} ‚Ç¨"
                
                tree.insert("", "end", values=(
                    formatted_date,
                    formatted_amount,
                    payment[2],
                    payment[3],
                    "Voir re√ßu"
                ), tags=(str(payment[4]),))
                
            # Configurer le tag pour le lien "Voir re√ßu"
            tree.tag_bind("receipt_link", "<Button-1>", 
                         lambda e: self.show_receipt(tree.item(tree.selection())["tags"][0]))
            
        except sqlite3.Error as e:
            CTkMessagebox(title="Erreur", 
                         message=f"Erreur lors du chargement de l'historique: {str(e)}", 
                         icon="cancel")
    
    def create_history_context_menu(self, tree, student_id):
        menu = tk.Menu(tree, tearoff=0)
        
        def popup(event):
            item = tree.identify_row(event.y)
            if item:
                tree.selection_set(item)
                menu.post(event.x_root, event.y_root)
        
        menu.add_command(label="Voir le re√ßu", 
                        command=lambda: self.show_receipt(tree.item(tree.selection())["tags"][0]))
        menu.add_command(label="Imprimer le re√ßu", 
                        command=lambda: self.print_receipt(student_id, tree.item(tree.selection())["tags"][0]))
        menu.add_separator()
        menu.add_command(label="Modifier", 
                        command=lambda: self.edit_payment(tree.item(tree.selection())["tags"][0]))
        menu.add_command(label="Supprimer", 
                        command=lambda: self.delete_payment(tree.item(tree.selection())["tags"][0]))
        
        tree.bind("<Button-3>", popup)  # Clic droit
        tree.bind("<Button-2>", popup)  # Clic milieu (pour macOS)
    
    def print_receipt(self, student_id=None, amount=None):
        if student_id is None:
            selected_item = self.payment_treeview.selection()
            if not selected_item:
                CTkMessagebox(title="Erreur", message="Veuillez s√©lectionner un √©l√®ve", icon="cancel")
                return
            student_id = self.payment_treeview.item(selected_item[0])['values'][0]
        
        try:
            from reportlab.lib import colors
            from reportlab.lib.pagesizes import A5
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import cm
            
            # R√©cup√©rer les informations de l'√©l√®ve
            cursor = self.conn.cursor()
            cursor.execute("""
                SELECT 
                    name || ' ' || surname as full_name,
                    class,
                    phone_number,
                    total_paid,
                    last_payment_date
                FROM Students
                WHERE id = ?
            """, (student_id,))
            
            student = cursor.fetchone()
            
            # Cr√©er le dossier des re√ßus s'il n'existe pas
            if not os.path.exists('receipts'):
                os.makedirs('receipts')
            
            # G√©n√©rer le nom du fichier
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"receipts/recu_paiement_{student_id}_{timestamp}.pdf"
            
            # Cr√©er le document PDF
            doc = SimpleDocTemplate(
                filename,
                pagesize=A5,
                rightMargin=1*cm,
                leftMargin=1*cm,
                topMargin=1*cm,
                bottomMargin=1*cm
            )
            
            # Styles
            styles = getSampleStyleSheet()
            header_style = ParagraphStyle(
                'HeaderStyle',
                parent=styles['Heading1'],
                fontSize=16,
                spaceAfter=30,
                alignment=1  # Centre
            )
            
            # Contenu
            elements = []
            
            # En-t√™te
            elements.append(Paragraph("RE√áU DE PAIEMENT", header_style))
            elements.append(Spacer(1, 20))
            
            # Informations
            data = [
                ["Date:", datetime.now().strftime("%d/%m/%Y %H:%M")],
                ["√âl√®ve:", student[0]],
                ["Classe:", student[1]],
                ["T√©l√©phone:", student[2] or "Non renseign√©"],
                ["Montant pay√©:", f"{amount:.2f} ‚Ç¨" if amount else f"{student[3]:.2f} ‚Ç¨"],
                ["Total pay√© √† ce jour:", f"{student[3]:.2f} ‚Ç¨"],
            ]
            
            # Cr√©er le tableau
            table = Table(data, colWidths=[4*cm, 8*cm])
            table.setStyle(TableStyle([
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 12),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
                ('GRID', (0, 0), (-1, -1), 0.25, colors.grey),
                ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
            ]))
            
            elements.append(table)
            
            # Ajouter un espace pour la signature
            elements.append(Spacer(1, 50))
            elements.append(Paragraph("Signature:", styles['Normal']))
            
            # G√©n√©rer le PDF
            doc.build(elements)
            
            # Ouvrir le PDF
            if sys.platform.startswith('darwin'):  # macOS
                os.system(f'open "{filename}"')
            elif sys.platform.startswith('win32'):  # Windows
                os.system(f'start "" "{filename}"')
            else:  # Linux
                os.system(f'xdg-open "{filename}"')
                
            CTkMessagebox(title="Succ√®s", 
                         message=f"Le re√ßu a √©t√© g√©n√©r√© : {filename}", 
                         icon="check")
            
        except Exception as e:
            CTkMessagebox(title="Erreur", 
                         message=f"Erreur lors de la g√©n√©ration du re√ßu : {str(e)}", 
                         icon="cancel")
    
    def sort_treeview(self, col):
        """Trier le treeview en cliquant sur les en-t√™tes de colonnes"""
        l = [(self.payment_treeview.set(k, col), k) for k in self.payment_treeview.get_children('')]
        l.sort(reverse=self.sort_reverse)
        self.sort_reverse = not self.sort_reverse
        
        # R√©organiser les √©l√©ments
        for index, (val, k) in enumerate(l):
            self.payment_treeview.move(k, '', index)
    		
    def create_reports_tab(self, tab):
        # Rapports et statistiques
        ctk.CTkLabel(tab, text="Rapports et Statistiques", font=("Arial", 20)).pack(pady=20)
        
        # Frame pour les boutons d'export
        export_frame = ctk.CTkFrame(tab)
        export_frame.pack(pady=10, fill="x", padx=20)
        
        # Frame pour les statistiques
        stats_frame = ctk.CTkFrame(tab)
        stats_frame.pack(pady=10, fill="both", expand=True, padx=20)
        
        # Boutons d'export
        export_buttons = [
            ("Exporter vers Excel", self.export_to_excel),
            ("G√©n√©rer PDF", self.generate_pdf),
            ("Statistiques de paiement", self.show_payment_stats)
        ]
        
        for text, command in export_buttons:
            ctk.CTkButton(export_frame, text=text, command=command).pack(pady=5, padx=10, fill="x")
    
        # Cr√©er un treeview pour afficher les statistiques
        self.stats_treeview = ttk.Treeview(stats_frame, columns=("M√©trique", "Valeur"), show="headings")
        self.stats_treeview.heading("M√©trique", text="M√©trique")
        self.stats_treeview.heading("Valeur", text="Valeur")
        self.stats_treeview.pack(pady=10, fill="both", expand=True)
    
        # Mettre √† jour les statistiques
        self.update_statistics()
    
    def export_to_excel(self):
        try:
            import pandas as pd
            from datetime import datetime
            
            # R√©cup√©rer les donn√©es avec plus de d√©tails
            cursor = self.conn.cursor()
            cursor.execute("""
                SELECT 
                    s.name as "Nom",
                    s.surname as "Pr√©nom",
                    s.class as "Niveau",
                    s.phone_number as "T√©l√©phone",
                    CASE WHEN s.payment_completed = 1 THEN 'Pay√©' ELSE 'Non pay√©' END as "Statut",
                    s.subjects as "Mati√®res",
                    s.registration_date as "Date d'inscription",
                    s.last_payment_date as "Dernier paiement",
                    s.total_paid as "Total pay√©"
                FROM Students s
            """)
            
            # Cr√©er le DataFrame
            columns = [description[0] for description in cursor.description]
            df = pd.DataFrame(cursor.fetchall(), columns=columns)
            
            # Cr√©er le nom du fichier
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"rapport_eleves_{timestamp}.xlsx"
            
            # Cr√©er le dossier 'exports' s'il n'existe pas
            if not os.path.exists('exports'):
                os.makedirs('exports')
            
            # Chemin complet du fichier
            filepath = os.path.join('exports', filename)
            
            # Exporter vers Excel avec mise en forme
            with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
                df.to_excel(writer, sheet_name='√âtudiants', index=False)
                
                # Ajuster la largeur des colonnes
                worksheet = writer.sheets['√âtudiants']
                for idx, col in enumerate(df.columns):
                    max_length = max(df[col].astype(str).apply(len).max(),
                                   len(col)) + 2
                    worksheet.column_dimensions[chr(65 + idx)].width = max_length
            
            CTkMessagebox(title="Succ√®s", 
                         message=f"Les donn√©es ont √©t√© export√©es vers:\n{filepath}", 
                         icon="check")
            
        except Exception as e:
            CTkMessagebox(title="Erreur", 
                         message=f"Erreur lors de l'export: {str(e)}", 
                         icon="cancel")
        
    def generate_pdf(self):
        try:
            from reportlab.lib import colors
            from reportlab.lib.pagesizes import letter
            from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
            from reportlab.lib.styles import getSampleStyleSheet
            
            # Cr√©er le dossier 'reports' s'il n'existe pas
            if not os.path.exists('reports'):
                os.makedirs('reports')
                
            # Nom du fichier PDF
            filename = f"rapport_complet_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
            filepath = os.path.join('reports', filename)
            
            # Cr√©ation du document
            doc = SimpleDocTemplate(filepath, pagesize=letter)
            styles = getSampleStyleSheet()
            elements = []
            
            # Titre
            title = Paragraph("Rapport de Gestion des Frais Scolaires", styles['Title'])
            elements.append(title)
            elements.append(Spacer(1, 20))
            
            # R√©cup√©rer les donn√©es
            cursor = self.conn.cursor()
            cursor.execute("""
                SELECT 
                    name, surname, class, phone_number,
                    CASE WHEN payment_completed = 1 THEN 'Pay√©' ELSE 'Non pay√©' END as status,
                    subjects
                FROM Students
            """)
            
            data = cursor.fetchall()
            
            # Cr√©er le tableau
            table_data = [['Nom', 'Pr√©nom', 'Niveau', 'T√©l√©phone', 'Statut', 'Mati√®res']] + list(data)
            t = Table(table_data)
            t.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 14),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 12),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            
            elements.append(t)
            
            # G√©n√©rer le PDF
            doc.build(elements)
            
            CTkMessagebox(title="Succ√®s", 
                         message=f"Le rapport PDF a √©t√© g√©n√©r√©:\n{filepath}", 
                         icon="check")
        except Exception as e:
            CTkMessagebox(title="Erreur", 
                         message=f"Erreur lors de la g√©n√©ration du PDF: {str(e)}", 
                         icon="cancel")
    
    def show_payment_stats(self):
        cursor = self.conn.cursor()
        
        # Effacer les anciennes statistiques
        for item in self.stats_treeview.get_children():
            self.stats_treeview.delete(item)
        
        try:
            # Statistiques g√©n√©rales
            stats = []
            
            # Total des √©tudiants
            cursor.execute("SELECT COUNT(*) FROM Students")
            total_students = cursor.fetchone()[0]
            stats.append(("Total des √©tudiants", total_students))
            
            # √âtudiants avec paiement complet
            cursor.execute("SELECT COUNT(*) FROM Students WHERE payment_completed = 1")
            paid_students = cursor.fetchone()[0]
            stats.append(("Paiements complets", paid_students))
            
            # √âtudiants avec paiement en attente
            pending_students = total_students - paid_students
            stats.append(("Paiements en attente", pending_students))
            
            # Taux de paiement
            if total_students > 0:
                payment_rate = (paid_students / total_students) * 100
                stats.append(("Taux de paiement", f"{payment_rate:.1f}%"))
            
            # Montant total re√ßu
            cursor.execute("SELECT SUM(total_paid) FROM Students")
            total_amount = cursor.fetchone()[0] or 0
            stats.append(("Montant total re√ßu", f"{total_amount:.2f} ‚Ç¨"))
            
            # Statistiques par niveau
            cursor.execute("""
                SELECT class, 
                       COUNT(*) as total,
                       SUM(CASE WHEN payment_completed = 1 THEN 1 ELSE 0 END) as paid
                FROM Students 
                GROUP BY class
            """)
            
            class_stats = cursor.fetchall()
            for class_name, total, paid in class_stats:
                stats.append((f"Classe {class_name} - Total", total))
                stats.append((f"Classe {class_name} - Pay√©", paid))
                if total > 0:
                    rate = (paid / total) * 100
                    stats.append((f"Classe {class_name} - Taux", f"{rate:.1f}%"))
            
            # Ajouter les statistiques au treeview
            for metric, value in stats:
                self.stats_treeview.insert("", "end", values=(metric, str(value)))
                
        except sqlite3.Error as e:
            print(f"Erreur SQL: {e}")
            self.stats_treeview.insert("", "end", values=("Erreur", str(e)))

    
    def update_statistics(self):
        self.show_payment_stats()
    def generate_financial_report(self):
        try:
            cursor = self.conn.cursor()
            cursor.execute("""
                SELECT 
                    SUM(p.amount) as total_collected,
                    COUNT(DISTINCT s.id) as total_students,
                    fc.amount as total_expected
                FROM Payments p
                JOIN Students s ON p.student_id = s.id
                CROSS JOIN FeeConfiguration fc
            """)
            report = cursor.fetchone()

            if report:
                total_collected, total_students, total_expected = report
                report_text = f"""
                RAPPORT FINANCIER
                ----------------
                Total √âl√®ves: {total_students}
                Total Collect√©: {total_collected} ‚Ç¨
                Total Attendu: {total_expected} ‚Ç¨
                Taux de Recouvrement: {(total_collected / total_expected) * 100:.2f}%
                Date du Rapport: {datetime.now().strftime('%d/%m/%Y')}
                """

                # Enregistrement du rapport
                with open('rapport_financier.txt', 'w') as f:
                    f.write(report_text)

                CTkMessagebox(
                    title="Rapport G√©n√©r√©",
                    message="Rapport financier sauvegard√© avec succ√®s !",
                    icon="check"
                )
        except Exception as e:
            CTkMessagebox(
                title="Erreur",
                message=f"Erreur de g√©n√©ration : {str(e)}",
                icon="cancel"
            )

    def generate_student_list(self):
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT name, surname, class FROM Students")
            students = cursor.fetchall()

            with open('liste_eleves.csv', 'w') as f:
                f.write("Nom,Pr√©nom,Classe\n")
                for student in students:
                    f.write(f"{student[0]},{student[1]},{student[2]}\n")

            CTkMessagebox(
                title="Liste G√©n√©r√©e",
                message="Liste des √©l√®ves export√©e en CSV !",
                icon="check"
            )
        except Exception as e:
            CTkMessagebox(
                title="Erreur",
                message=f"Erreur d'exportation : {str(e)}",
                icon="cancel"
            )

    def generate_payment_status(self):
        try:
            cursor = self.conn.cursor()
            cursor.execute("""
                SELECT 
                    s.name,
                    s.surname,
                    s.class,
                    fc.amount as total_fee,
                    COALESCE(SUM(p.amount), 0) as paid_amount,
                    (fc.amount - COALESCE(SUM(p.amount), 0)) as remaining_amount
                FROM Students s
                CROSS JOIN FeeConfiguration fc
                LEFT JOIN Payments p ON s.id = p.student_id
                GROUP BY s.id
            """)

            with open('status_paiements.csv', 'w') as f:
                f.write("Nom,Pr√©nom,Classe,Frais Total,Montant Pay√©,Reste √† Payer\n")
                for student in cursor.fetchall():
                    f.write(f"{student[0]},{student[1]},{student[2]},{student[3]},{student[4]},{student[5]}\n")

            CTkMessagebox(
                title="Statut G√©n√©r√©",
                message="Statut des paiements export√© !",
                icon="check"
            )
        except Exception as e:
            CTkMessagebox(
                title="Erreur",
                message=f"Erreur de g√©n√©ration : {str(e)}",
                icon="cancel"
            )

    def create_required_tables(self):
        """Cr√©e les tables de la base de donn√©es"""
        try:
            cursor = self.conn.cursor()
    
	
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS LoginHistory (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    email TEXT NOT NULL,
                    status TEXT NOT NULL,
                    login_time DATETIME DEFAULT CURRENT_TIMESTAMP,
                    ip_address TEXT,
                    FOREIGN KEY(user_id) REFERENCES Users(id)
                )
            ''')
            
            # Table pour les sessions utilisateurs
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS UserSessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    session_id TEXT UNIQUE NOT NULL,
                    user_id INTEGER NOT NULL,
                    email TEXT NOT NULL,
                    start_time DATETIME DEFAULT CURRENT_TIMESTAMP,
                    last_activity DATETIME DEFAULT CURRENT_TIMESTAMP,
                    ip_address TEXT,
                    active INTEGER DEFAULT 1,
                    FOREIGN KEY(user_id) REFERENCES Users(id)
                )
            ''')
            # Table Configuration des Frais
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS FeeConfiguration (
                    id INTEGER PRIMARY KEY,
                    level TEXT,
                    amount REAL
                )
            ''')
    
            # Table des Mati√®res
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS Subjects (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    level TEXT NOT NULL,
                    name TEXT NOT NULL,
                    fee REAL NOT NULL,
                    UNIQUE(level, name)
                )
            ''')
    
            # Table √âcole
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS School (
                    id INTEGER PRIMARY KEY,
                    name TEXT NOT NULL,
                    address TEXT NOT NULL,
                    phone TEXT NOT NULL,
                    email TEXT NOT NULL,
                    website TEXT,
                    director TEXT NOT NULL,
                    logo_path TEXT,
                    description TEXT,
                    academic_year TEXT NOT NULL,
                    last_updated DATETIME,
                    created_by TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    modified_by TEXT,
                    modified_at DATETIME
                )
            ''')
    
            # Table pour les trimestres - Version corrig√©e
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS SchoolTerms (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    term_number INTEGER NOT NULL,
                    start_date TEXT NOT NULL,
                    end_date TEXT NOT NULL,
                    academic_year TEXT NOT NULL,
                    created_by TEXT,
                    created_at DATETIME,
                    modified_by TEXT,
                    modified_at DATETIME,
                    UNIQUE(term_number, academic_year)
                )
            ''')
    
            # Table pour les vacances
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS SchoolHolidays (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    start_date TEXT NOT NULL,
                    end_date TEXT NOT NULL,
                    academic_year TEXT NOT NULL,
                    created_by TEXT,
                    created_at DATETIME,
                    modified_by TEXT,
                    modified_at DATETIME
                )
            ''')
    
            # Table pour les param√®tres de notification
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS NotificationSettings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    notification_type TEXT NOT NULL,
                    enabled BOOLEAN NOT NULL DEFAULT 0,
                    created_by TEXT,
                    created_at DATETIME,
                    modified_by TEXT,
                    modified_at DATETIME
                )
            ''')
    
            # Table √âl√®ves
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS Students (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    surname TEXT NOT NULL,
                    birth_date TEXT,
                    gender TEXT,
                    address TEXT,
                    class TEXT NOT NULL,
                    phone_number TEXT,
                    parent_name TEXT,
                    parent_phone TEXT,
                    email TEXT,
                    registration_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    photo_path TEXT,
                    subjects TEXT,
                    total_fee REAL DEFAULT 0,
                    total_paid REAL DEFAULT 0,
                    last_payment_date TEXT,
                    payment_completed INTEGER DEFAULT 0
                )
            ''')
    
            # Table Paiements
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS Payments (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    student_id INTEGER,
                    amount REAL NOT NULL,
                    payment_date TEXT DEFAULT CURRENT_TIMESTAMP,
                    payment_method TEXT,
                    notes TEXT,
                    FOREIGN KEY(student_id) REFERENCES Students(id)
                )
            ''')
    
            # Table pour les documents des √©tudiants
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS StudentDocuments (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    student_id INTEGER,
                    document_type TEXT NOT NULL,
                    file_path TEXT NOT NULL,
                    uploaded_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY(student_id) REFERENCES Students(id)
                )
            ''')
    
            # Table pour l'historique des modifications
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS AuditLog (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    table_name TEXT NOT NULL,
                    record_id INTEGER NOT NULL,
                    action TEXT NOT NULL,
                    user_login TEXT NOT NULL,
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                    old_values TEXT,
                    new_values TEXT
                )
            ''')
    
            self.conn.commit()
            logging.info("Tables cr√©√©es avec succ√®s")
    
        except sqlite3.Error as e:
            logging.error(f"Erreur lors de la cr√©ation des tables: {e}")
            self.conn.rollback()
            raise
		
		
def main():
    root = ctk.CTk()
    app = LoginWindow(root)
    root.mainloop()
	
if __name__ == "__main__":
    main()
